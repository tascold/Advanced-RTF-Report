PARAMETERS f_shabl, f_othet, rep_config
	rep_time=SECONDS()
	ret_error=RTF_REPORT(m.f_shabl,m.f_othet,m.rep_config)
	rep_time=SECONDS()-m.rep_time
	? "Время выполнения: "+STR(INT(rep_time/60),3)+":"+CHRTRAN(STR(MOD(rep_time,60),2)," ","0")+" сек."
	IF !EMPTY(m.ret_error)
		=MESSAGEBOX(m.ret_error,16,"Ошибка")
	ENDIF
RETURN m.ret_error
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION RTF_REPORT	&& формирование отчета на основе описанного RTF шаблона
PARAMETERS f_shabl, f_othet, rep_config
* f_shabl - файл шаблона
* f_othet - файл результата
* rep_config - Конфигурация запуска - может содержать любой набор из нижеперечисленных вариантов:
*	[SHOW]  - показать отчет
*	[ADDF]  - автоматически создавать файл результата с возрастающим номером, в случае, если не удается переписать файл
*	[MERGE] - Объединить текущий результат с существующим файлом WORD. Исключает параметр [ADDF]
*	[HIDE]  - не показывать сообщения пользователю о процессе генерации
*	[PRINT] или [PRINT=имя_принтера] - для печати отчета без просмотра. После знака равенства можно задать целевой принтер.
*	[COPIES=*] для печати * копий отчета.
*	[PAGES=1,2,5-8] для печати заданных страниц | [PAGES=BOOK] для формирования книжки | [PAGES=SIDE] - для печати четных и нечетных страниц
* 	[FORMAT] - Обновление оглавления, если оно есть (только если установлен MS Office)
*	[ENCODE=N] - Позволяет записывать все данные отчета в перекодированном виде. Варианты N см. в параметрах ф-и STRCONV()
* 	[EXCEL] - Не зависимо от настроек POINT() для числовых полей в качестве разделителей ставит запятые.
*--------------------------------------------------------------------------------------------
* Ver 1.0 - 2010 г.
*--------------------------------------------------------------------------------------------
* Генератор предназначен для получения RTF отчетов без использования WORD а также текстовых 
* отчетов с заданной структурой (например, XML или HTML). Имеет гибкую структуру, 
* позволяющую последовательно добавлять неограниченное количество таблиц. Также можно вложить таблицу 
* в контейнер и размножить ее по количеству записей в таблице контейнера. Скорость генерации - 5-50 
* листов в секунду.
* 
* Подключать необходимо либо по SET PROC, либо выполнять как DO - см. приложенную форму.
*
* @ Разработчик: TAS - Тимошенко Аскольд Сергеевич
* С вопросами и предложениями обращаться на E-Mail: tascold@mail.ru
* Данное решение находится на сайте http://www.foxclub.ru/sol/solution666.php в разделе решения с наименованием: Advanced RTF Report
*--------------------------------------------------------------------------------------------
* Ver 1.1 - 2010 г.
*--------------------------------------------------------------------------------------------
*	1. ADD: Добавлена возможность обратной сортировки, для этого конструкцию "ORD=выражение" писать 
*           как "ORD=DESC:выражение"
*	2. ADD: Добавлен показ % выполнения формирования разделов отчета
*	3. ADD: Добавлена возможность замены русских букв на HEX-коды при обработке символьных переменных
*--------------------------------------------------------------------------------------------
* Ver 1.2 - 2010 г.
*--------------------------------------------------------------------------------------------
*	1. ADD: Добавлены теги CASE, OTHERWISE, ENDCASE
*	2. ADD: Добавлен предварительный подсчет кол-ва разделов и вывод в градуснике "*** из ***"
*	3. IZM: Изменен метод запуска готового файла на WScript
*--------------------------------------------------------------------------------------------
* Ver 1.3 - 2010 г.
*--------------------------------------------------------------------------------------------
*	1. ADD: Добавлена возможность вывода в отчет PNG файлов (конструкция IMG: в описании символьных переменных)
*	2. ADD: Для картинок (переменных с IMG:) можно задавать 3 типа рамки: RM1-простая рамка,RM2-рамка 
*           с тенью,RM3-двойная рамка
*	3. ADD: Добавлена возможность разделения разрядов при обработке числовых переменных (конструкция RAZ:)
*	4. ADD: Добавлен вывод ДА/НЕТ при обработке логических переменных (конструкция LRU:)
*--------------------------------------------------------------------------------------------
* Ver 1.4 - 2010 г.
*--------------------------------------------------------------------------------------------
*	1. ERR: Исправлена неадекватная работа счетчика str_tbl (не сбрасывался на 0 при смене таблицы)
*	2. ERR: Исправлен рабочий алиас заголовка и подвала контейнера (переменные не отрабатывались 
*           правильно без явного указания алиаса контейнера)
*	3. ADD: Добавлена возможность задавать условие в теге [ALI] как USL$выражение для поиска по списку. 
*           Условием для добавления записей в таблицу, находящуюся в группе, в этом случае является: 
*           выражение IN (ключ), т.е. ключ должен быть вида "1,2,3" или "'AA','BB','CC'". 
*--------------------------------------------------------------------------------------------
* Ver 1.5 - 2010 г.
*--------------------------------------------------------------------------------------------
*	1. ADD: Добавлена возможность задавать подстановки для переменных (конструкция REPVAR*:) Потом доступно 
*           использование в переменных вида [&*], где * - ID подстановки). Переменная наследует все функции 
*           подстановки, при этом функции переменной приоритетней функций подстановки.
*	2. IZM  Ранее переменные переводились UPPER() теперь этого не делается.  Это сделано для того, чтобы переменные вида
*           ["Дата:"+DTOC(DATE())] выводились в виде "Дата:..." а не "ДАТА:...". Индексы, условия, 
*           группировки и сортировки остались регистронезависимыми (переводятся в UPPER() перед обработкой)!
*--------------------------------------------------------------------------------------------
* Ver 1.6 - 2010 г.
*--------------------------------------------------------------------------------------------
*	1. ADD: Добавлен параметр [ADDF] в конфигурации запуска для подавления ошибки создания выходного файла. В случае, 
*           если файл результата не может быть перезаписан, добавляет к имени файла "_N", где N может быть от 1 до 49 и
*           пытается записать с новым именем. При достижении N=50, формирует ошибку доступа к диску. 
*	2. ADD: Добавлена возможность вывода в отчет JPG файлов.
*--------------------------------------------------------------------------------------------
* Ver 2.0 - 2010 г.
*--------------------------------------------------------------------------------------------
*	ВНИМАНИЕ! VER 2.0 НЕСОВМЕСТИМА С ПРЕДЫДУЩИМИ ВЕРСИЯМИ В ПЛАНЕ СЧЕТЧИКОВ И АЛИАСОВ ГРУПП!!!
*--------------------------------------------------------------------------------------------
*	1. ADD: Добавлена возможность добавлять подгруппы. Подгруппы объявляются также как и группы.
*			МАХ вложенность групп=6.
*	2. IZM: Полностью изменен подход к счетчикам, теперь их стало 72 штуки.
*	3. IZM: Алиас группы изменился с GRP на GR1,GR2,GR3... - в зависимости от вложенности
*--------------------------------------------------------------------------------------------
* Ver 2.1 - 2010 г.
*--------------------------------------------------------------------------------------------
*	1. ERR: Поправлен счетчик [tbl_str] (в некоторых случаях считал неверно)
*	2. ERR: Исправлена ошибка обработки файлов у которых внутренние шрифты указаны без кодировки.
*	3. ADD: Добавлена функция форматирования "BLZ" - выводит число 1000000 как 1 000 000, разделяя разряды пробелами,
*			при этом если число=0, то не выводит ничего.
*	4. ADD: Добавлена функция форматирования "BLK" - если число=0, то не выводит ничего.
*	5. ADD: Добавлен параметр [HIDE] в конфигурации запуска для подавления сообщений процесса генерации
*--------------------------------------------------------------------------------------------
* Ver 2.2 - 2010 г.
*--------------------------------------------------------------------------------------------
*	1. ERR: Поправлены косяки с подстановками в переменных. (Для ряда функций брались не те данные)
*	2. ADD: В целях унификации шаблонов добавлена подстановка "&" при описании контейнеров, таблиц или групп. 
*           Пример использования [REP:ALI=&myalias|ORD=&myorder] - здесь в "ALI=&myalias" - "&" - признак подстановки, 
*           "myalias" - переменная, которая содержит значения алиаса. Так же и для сортировки.  
*           Переменные "myalias" и "myorder" должны быть описаны до запуска генератора!
*			Подстановка может быть использована для любой секции и позволит многократно использовать один и 
*           тот же шаблон для схожих по структуре данных.
*	3. ADD: Добавлена функция преобразования "RD3" - округление до 3 знаков после запятой.
*	4. ADD: Добавлена пользовательская функция форматирования переменных: конструкция "FUN=USERFUNC" или 
*           "FUN=USERFUNC(m.znh_now)". Если нужно в вашу функцию передать более одного значения, то для передачи 
*           текущего значения поля нужно пользоваться переменной m.znh_now.Если параметр только один, то задавать 
*           его не нужно - будет автоматически добавлено к имени функции концовка "(m.znh_now)"!
*           Эта конструкция разделяется двоеточием от остальных функций. Выполняется после всех преобразований, 
*           при этом имейте ввиду, что тип переменной m.znh_now в момент запуска пользовательской функции, всегда 
*           символьный! На выходе также ожидается значение символьного типа!
*--------------------------------------------------------------------------------------------
* Ver 2.3 - 2010 г.
*--------------------------------------------------------------------------------------------
*	1. ERR: Поправлен подвал группировок и ссылки на другие группы. (Теперь в алиасе, на который ссылается 
*           переменная, указатель записи из EOF() переводится на BOTTOM).
*	2. ERR: Исправлена ошибка с ограничением до 3, распознавания секций в описании переменных. В связи с этим 
*           часть ф-й могли не распознаться. (Теперь увеличено до 10)
*	3. IZM: Теперь концовка к имени пользовательской функции форматирования переменных добавляется не "(m.znh_now)" 
*           a "(m.znh_val)". Проверьте свои шаблоны!
*	4. ADD: Добавлена переменная ZNH_VAL с вычисленным, но не преобразованным значением для использования во внешних 
*           функциях. Тип переменной ZNH_VAL тот, который имеет поле (выражение) в источнике. 
*           ВНИМАНИЕ! Если вы используете внешнюю функцию с переменной ZNH_VAL, то функции преобразования и 
*           форматирования задавать бессмысленно!
*	5. ADD: Добавлена переменная ZNH_CON с вычисленным и преобразованным но не отформатированным значением 
*           для использования во внешних функциях. Тип переменной ZNH_CON тот, который имеет который имеет 
*           функция преобразования на выходе. 
*           ВНИМАНИЕ! Если вы используете внешнюю функцию с переменной ZNH_CON, то функции форматирования 
*           задавать бессмысленно!
*--------------------------------------------------------------------------------------------
* Ver 2.4 - 2010 г.
*--------------------------------------------------------------------------------------------
*	1. ERR: Исправлена ошибка с длинными путями при показе готового отчета (теперь полное имя файла оборачивается в кавычки)
*	2. ADD: Добавлен параметр [PRINT] или [PRINT=имя_принтера] в конфигурации запуска для печати отчета без просмотра. 
*			После знака равенства можно задать целевой принтер.
*	3. ADD: Добавлен параметр [COPIES=*] для печати * копий отчета. Актуально только совместно с [PRINT]
*	4. ADD: Добавлен параметр [PAGES=1,2,5-8] для печати заданных страниц | [PAGES=BOOK] для формирования книжки  | [PAGES=SIDE] - для печати четных и нечетных страниц 
*			Актуально только совместно с [PRINT]
*--------------------------------------------------------------------------------------------
* Ver 2.5 - 2011 г.
*--------------------------------------------------------------------------------------------
*	1. ADD: Добавлен параметр [MERGE] - Позволяет объединять текущий результат с существующим файлом WORD. 
*	2. IZM: Тег [ENDPAGE] теперь не срабатывает на последних записях текущей таблицы
*	3. ADD: У тега [ENDPAGE] добавлена возможность задавать условие срабатывания: конструкция USL=выражение (задается через разделитель "|")
*	4. ADD: Добавлена пост обработка полученного файла (параметр [FORMAT]): обновление оглавления, если оно есть (только если установлен MS Office)
*	5. IZM: Оптимизация ввода/вывода. Существенное ускорение разборки шаблонов отчетов.
*	6. ADD: Добавлена функция форматирования "TDT" – преобразует DATETIME значение в тип DATE.
*	7. ERR: Исправлена ошибка исполнения условий объектов в безалиасной зоне.
*--------------------------------------------------------------------------------------------
* Ver 2.6 - 2013 г.
*--------------------------------------------------------------------------------------------
*	Добавлена функция SPLIT_REPORT(), надстройка над RTF_REPORT() - дает возможность разделения отчета на несколько файлов. Здесь и далее будут 
*	использоваться ссылки, для привязки изменений к конкретной функции.
*	[1] - изменения для функции RTF_REPORT()
*	[2] - изменения для функции SPLIT_REPORT()
*--------------------------------------------------------------------------------------------
*	1. [1].ADD: Генератор можно использовать для формирования текстовых (HTML и XML) отчетов.
*	2. [1].ERR: Исправлена ошибка применения условия таблицы, заданной вне контейнера
*	3. [1].ADD: Добавлен параметр [COD=N] - Позволяет записывать данные поля в перекодированном виде. Варианты N см. в параметрах ф-и STRCONV()
*				Параметр [COD] имеет более высокий приоритет, чем параметр [ENCODE].
*	4. [1].ADD: Добавлен параметр [ENCODE=N] - Позволяет записывать все данные отчета в перекодированном виде. Варианты N см. в параметрах ф-и STRCONV()
*				(Например, есть шаблон в кодировке 1251, необходимо сохранить XML файл в кодировке utf-8). 
*	5. [2].ADD: Добавлена функция SPLIT_REPORT(), надстройка над RTF_REPORT() - дает возможность разделения отчета на несколько файлов.
*	6. [2].ADD: Добавлен ОБЯЗАТЕЛЬНЫЙ параметр [SPLIT=*] - где "*" - MAX количество записей в томе.
*	7. [2].ADD: Добавлен параметр [STOMS=1,2,5-8] для формирования только указанных томов.
*--------------------------------------------------------------------------------------------
* Ver 2.7 - 2015 г.
*--------------------------------------------------------------------------------------------
*	1. [1].ADD: Добавлена функция преобразования "PAR" - для добавления текста содержащего несколько строк в виде отдельных параграфов. Актуально только для RTF файла.
*--------------------------------------------------------------------------------------------
* Ver 2.8 - 2018 г.
*--------------------------------------------------------------------------------------------
*	1. [1].ERR: Добавлена проверка длины наименования функции преобразования, чтобы исключить их срабатывание при похожем начале имени переменной и установкой SET EXACT OFF.
*	2. [1].ADD: Добавлена функция преобразования "ML5" - масштабирование (уменьшение) картинки на 50% (актуально только для конструкции "IMG").
*--------------------------------------------------------------------------------------------
* Ver 2.9 - 2018 г.
*--------------------------------------------------------------------------------------------
*	1. [1].IZM: Более чем в 2 раза ускорена функция разборки шаблона READ_RTF().
*--------------------------------------------------------------------------------------------
* Ver 3.0 - 2019 г.
*--------------------------------------------------------------------------------------------
*	Добавлена функция XLS_REPORT, надстройка над RTF_REPORT() для формирования отчетов в EXCEL с использованием XML шаблонов. 
*   Добавлена функция DBF_TOEXCEL - продвинутая выгрузка данных курсора в EXCEL. Может использоваться отдельно.
*	[1] - изменения для функции RTF_REPORT()
*	[2] - изменения для функции SPLIT_REPORT()
*	[3] - изменения для функции XLS_REPORT()
*	[4] - изменения для функции DBF_TOEXCEL()
*--------------------------------------------------------------------------------------------
*	1. [1].ADD: Добавлена поддержка выгрузки в EXCEL.
*	2. [3].ADD: Добавлена функции XLS_REPORT().
*	3. [4].ADD: Добавлена функции DBF_TOEXCEL().
*--------------------------------------------------------------------------------------------
* Ver 3.1 - 2019 г.
*--------------------------------------------------------------------------------------------
*	1. [1].IZM: Добавлена функция преобразования "NUM" - для приведения типа ячейки к числовому формату (актуально только для формирования отчетов в EXCEL).
*--------------------------------------------------------------------------------------------
* Ver 3.2 - 2019 г.
*--------------------------------------------------------------------------------------------
*	1. [1].IZM: Функция ENCODE_SYMBOLS переписана для более быстрого выполнения.
*	2. [3].ADD: Добавлен тег «[REP:NOTE]» для добавления в шаблон строк с комментариями (актуален только для шаблонов EXCEL). В готовый отчет эти строки добавлены не будут.
*--------------------------------------------------------------------------------------------
* Ver 3.3 - 2019 г.
*--------------------------------------------------------------------------------------------
*	1. [1].IZM: Добавлена возможность вывода в WORD отчет PNG графиков (нужен EXCEL!!!, конструкция DIA: GEN_DIAGR() - см. пример для WORD № 12)
*	2. [3].IZM: Добавлен 4-й параметр для конвертации результата в большое кол-во форматов. Теперь по умолчанию результат остается в XML виде.
*	3. [3].IZM: Изменен подход к шаблонам с выделенной служебной колонки на служебные строки (см. примеры EXCEL).
*--------------------------------------------------------------------------------------------
	IF VARTYPE(m.rep_config)#"C"
		rep_config=''
	ENDIF
	f_shabl = ALLTRIM(m.f_shabl)
	LOCAL i,form_ret,file_nom,file_name,f_printer,f_pcopies,f_conftxt,openword,loWord,file_id
	PRIVATE f_out,rep_errs,proc_all,proc_now,proc_kol,proc_rzd,proc_lvl,proc_glv,alias_in,reps_cod
	rep_errs=''	&& переменная для ошибки
	proc_all=0	&& всего шагов для текущего proc_rzd
	proc_now=0	&& текущий шаг
	proc_kol=0	&& кол-во %
	proc_rzd=0	&& раздел
	proc_lvl=0	&& уровень 1-контейнер, 2-группа, 3-строка
	reps_cod=0	&& перекодировка файла
	alias_in=ALIAS()	&& текущий алиас
	FOR i=1 TO GETWORDCOUNT(m.rep_config,"]")
		f_conftxt=ALLTRIM(GETWORDNUM(m.rep_config,m.i,"]"))
		DO CASE
		CASE ALLTRIM(UPPER(LEFT(m.f_conftxt,8)))=="[ENCODE="
			reps_cod=VAL(SUBSTR(m.f_conftxt,AT("=",m.f_conftxt)+1))
			reps_cod=IIF(BETWEEN(m.reps_cod,1,16),m.reps_cod,0)
		ENDCASE
	ENDFOR
*--------------------------------------------------------------------------------------------
* загрузка структуры
*--------------------------------------------------------------------------------------------
	WAIT WINDOW IIF("[HIDE]"$UPPER(m.rep_config),"","Идет загрузка структуры") NOWAIT NOCLEAR
*aaa=SECONDS()
	form_ret=READ_RTF(m.f_shabl)	&& формирование струтуры
*WAIT WINDOW STR(SECONDS()-aaa,10,2)
*--------------------------------------------------------------------------------------------
* генерация отчета
*--------------------------------------------------------------------------------------------
	file_nom=0			&& для № файла
	file_name=m.f_othet	&& запоминается оригинальное имя файла
	IF m.form_ret=1
		proc_glv=GET_RAZDKOL()	&& получение количества независимых разделов в шаблоне
		DO WHILE .T.
			IF "[MERGE]"$UPPER(m.rep_config) AND FILE(m.f_othet)
				rep_config=STRTRAN(m.rep_config,"[ADDF]","")
				m.f_othet=SYS(2023)+"\"+SYS(2015)+".rtf"	&& временное имя файла
			ENDIF
			f_out = FCREATE(m.f_othet)
			DO CASE
			CASE m.f_out<0 AND "[ADDF]"$UPPER(m.rep_config)
				IF m.file_nom<50
					file_nom=m.file_nom+1
					f_othet=ADDBS(JUSTPATH(m.file_name))+JUSTSTEM(m.file_name)+"_"+ALLTRIM(STR(m.file_nom))+"."+JUSTEXT(m.file_name)
				ELSE
			    	rep_errs='Ошибка создания выходного файла! Проверьте наличие доступа к папке: '+ADDBS(JUSTPATH(m.file_name))
			    	form_ret=-1
			    	EXIT
				ENDIF
			CASE m.f_out<0
		    	rep_errs='Ошибка создания выходного файла! Возможно этот файл открыт в WORD?'
		    	form_ret=-1
		    	EXIT
			OTHERWISE
				form_ret=ADD_REP()				&& формирование тела файла
				=FCLOSE(m.f_out)
		    	EXIT
			ENDCASE
		ENDDO
	ENDIF
*--------------------------------------------------------------------------------------------
* объединение полученного результата с существующим файлом по опции [MERGE]
*--------------------------------------------------------------------------------------------
	IF m.form_ret=1 AND "[MERGE]"$UPPER(m.rep_config) AND FILE(m.f_othet)
		WAIT WINDOW IIF("[HIDE]"$UPPER(m.rep_config),"","Идет объединение файлов...") NOWAIT NOCLEAR
		openword=0
		file_id=FOPEN(m.file_name,12)
		IF m.file_id<=0	&& файл не удалось открыть на запись
			form_ret=-1
			rep_errs='Ошибка объединения полученного результата с существующим файлом! Возможно этот файл открыт в WORD?'
		ELSE
			=FCLOSE(m.file_id)
			TRY
				loWord=CREATEOBJECT('Word.Application')
				loWord.Visible=.F.
				openword=1					&& добрались до этой строки - значит будем закрывать WORD при завершении
				loBook = loWord.Documents.open(FULLPATH(m.file_name))
				loWord.ActiveDocument.Range.Select
				loWord.Selection.EndKey(6)
				loWord.Selection.TypeParagraph				&& добавляем новый параграф с очищенным форматированием
				loWord.Selection.ClearFormatting
				loWord.Selection.InsertBreak(2)
				loWord.Selection.InsertFile(FULLPATH(m.f_othet))
				loWord.Selection.HomeKey(6)
				loWord.DisplayAlerts = 0 
				loWord.ActiveDocument.Save()
				loWord.Quit(0)
				LoWord=.NULL.
				DELETE FILE (m.f_othet)	&& удаляем временный файл
				f_othet=m.file_name
			CATCH TO goto_error
		    	rep_errs='Ошибка объединения полученного результата с существующим файлом! Возможно этот файл открыт в WORD?'
				form_ret=-1
				IF m.openword=1
					LoWord.Quit(0)
					LoWord=.NULL.
				ENDIF
			ENDTRY
		ENDIF
	ENDIF
*--------------------------------------------------------------------------------------------
* Обновление оглавления (если есть)
*--------------------------------------------------------------------------------------------
	IF m.form_ret=1 AND "[FORMAT]"$UPPER(m.rep_config)
		WAIT WINDOW IIF("[HIDE]"$UPPER(m.rep_config),"","Идет форматирование...") NOWAIT NOCLEAR
		TRY
			openword=0
			loWord=CREATEOBJECT('Word.Application')
			loWord.Visible=.f.
			openword=1					&& добрались до этой строки - значит будем закрывать WORD при завершении
			loBook = m.loWord.Documents.Open(FULLPATH(m.file_name))
			IF loBook.TablesOfContents.Count>0			&& если есть оглавление
				loBook.TablesOfContents.Item(1).Update	&& то обновляем его
			ENDIF
			loWord.DisplayAlerts = 0 
			loWord.ActiveDocument.Save()
		CATCH TO goto_error
		ENDTRY
		IF m.openword=1
			LoWord.Quit(0)
			LoWord=.NULL.
		ENDIF
	ENDIF
	IF "[HIDE]"$UPPER(m.rep_config)=.F.
		WAIT CLEAR
	ENDIF
*--------------------------------------------------------------------------------------------
* запуск просмотра готового файла
*--------------------------------------------------------------------------------------------
	IF m.form_ret=1
		DO CASE
		CASE "[SHOW]"$UPPER(m.rep_config)	&& Показать отчет
			WSHShell=CreateObject("WScript.Shell",0,.F.)
			WSHShell.Run('"'+m.f_othet+'"')
		CASE "[PRINT"$UPPER(m.rep_config)	&& Печать
			f_printer=''
			f_pcopies=1
			f_pages=''
			FOR i=1 TO GETWORDCOUNT(m.rep_config,"]")
				f_conftxt=ALLTRIM(GETWORDNUM(m.rep_config,m.i,"]"))
				DO CASE
				CASE ALLTRIM(UPPER(LEFT(m.f_conftxt,7)))=="[PRINT="
					f_printer=ALLTRIM(SUBSTR(m.f_conftxt,AT("=",m.f_conftxt)+1))
				CASE ALLTRIM(UPPER(LEFT(m.f_conftxt,8)))=="[COPIES="
					f_pcopies=VAL(SUBSTR(m.f_conftxt,AT("=",m.f_conftxt)+1))
				CASE ALLTRIM(UPPER(LEFT(m.f_conftxt,7)))=="[PAGES="
					f_pages=SUBSTR(m.f_conftxt,AT("=",m.f_conftxt)+1)
				ENDCASE
			ENDFOR
			WAIT WINDOW IIF("[HIDE]"$UPPER(m.rep_config),"","Идет печать документа...") NOWAIT NOCLEAR
			IF PrintAny(m.f_othet,m.f_printer,m.f_pcopies,m.f_pages)<=0
		    	rep_errs='Ошибка при печати WORD документа!'
			ENDIF
			IF "[HIDE]"$UPPER(m.rep_config)=.F.
				WAIT CLEAR
			ENDIF
		ENDCASE
	ENDIF
*--------------------------------------------------------------------------------------------
	IF USED("_rtfreport")
		USE IN _rtfreport
	ENDIF
	IF USED("_rtftables")
		USE IN _rtftables
	ENDIF
	IF USED("_rtfvables")
		USE IN _rtfvables
	ENDIF
	IF !EMPTY(m.alias_in) AND USED(m.alias_in)
		SELECT (m.alias_in)
	ENDIF
RETURN m.rep_errs 	&& пустая, если все ОК!
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION ADD_REP	&& головная ф-я формирования выходного файла
	LOCAL rep_okey,tbl_alia
*--------------------------------------------------------------------------------------------
* Переменные для счетчиков
*--------------------------------------------------------------------------------------------
	DIMENSION rep_shet(72)	&& массив счетчиков
	PRIVATE rep_con,rep_tbl,rep_gr1,rep_gr2,rep_gr3,rep_gr4,rep_gr5,rep_gr6,rep_str
	PRIVATE con_all,con_now,con_str,con_tbl,con_gr1,con_gr2,con_gr3,con_gr4,con_gr5,con_gr6
	PRIVATE tbl_all,tbl_now,tbl_str,tbl_gr1,tbl_gr2,tbl_gr3,tbl_gr4,tbl_gr5,tbl_gr6,tbl_kol
	PRIVATE gr1_all,gr1_now,gr1_str,gr1_gr2,gr1_gr3,gr1_gr4,gr1_gr5,gr1_gr6,gr1_kol,gr1_tek
	PRIVATE gr2_all,gr2_now,gr2_str,gr2_gr3,gr2_gr4,gr2_gr5,gr2_gr6,gr2_kol,gr2_tek
	PRIVATE gr3_all,gr3_now,gr3_str,gr3_gr4,gr3_gr5,gr3_gr6,gr3_kol,gr3_tek
	PRIVATE gr4_all,gr4_now,gr4_str,gr4_gr5,gr4_gr6,gr4_kol,gr4_tek
	PRIVATE gr5_all,gr5_now,gr5_str,gr5_gr6,gr5_kol,gr5_tek
	PRIVATE gr6_all,gr6_now,gr6_tek
	rep_shet=0				&& обнуление массива счетчиков
	STORE 0 TO rep_con,rep_tbl,rep_gr1,rep_gr2,rep_gr3,rep_gr4,rep_gr5,rep_gr6,rep_str
	STORE 0 TO con_all,con_now,con_str,con_tbl,con_gr1,con_gr2,con_gr3,con_gr4,con_gr5,con_gr6
	STORE 0 TO tbl_all,tbl_now,tbl_str,tbl_gr1,tbl_gr2,tbl_gr3,tbl_gr4,tbl_gr5,tbl_gr6,tbl_kol
	STORE 0 TO gr1_all,gr1_now,gr1_str,gr1_gr2,gr1_gr3,gr1_gr4,gr1_gr5,gr1_gr6,gr1_kol,gr1_tek
	STORE 0 TO gr2_all,gr2_now,gr2_str,gr2_gr3,gr2_gr4,gr2_gr5,gr2_gr6,gr2_kol,gr2_tek
	STORE 0 TO gr3_all,gr3_now,gr3_str,gr3_gr4,gr3_gr5,gr3_gr6,gr3_kol,gr3_tek
	STORE 0 TO gr4_all,gr4_now,gr4_str,gr4_gr5,gr4_gr6,gr4_kol,gr4_tek
	STORE 0 TO gr5_all,gr5_now,gr5_str,gr5_gr6,gr5_kol,gr5_tek
	STORE 0 TO gr6_all,gr6_now,gr6_tek
*--------------------------------------------------------------------------------------------
	rep_okey=1
	tbl_alia=GET_REPALIAS("[REP]")
	SELECT * FROM _rtfreport WHERE !INLIST(obtype,3,4,5,6,9,12,13,14,15) AND EMPTY(rodrid) INTO CURSOR (m.tbl_alia) READWRITE
	SCAN			&& 1 раз по каждому разделу верхнего уровня кроме группировок и детайл
		proc_lvl=0	&& сброс уровня отображения % в начале каждого раздела
		DO CASE
		CASE obtype=2
			rep_okey=ADD_TBL(rnomer,tnomer,grnext,grpend)	&& отвечает также за добавление 3,4,5,6
		CASE obtype=10
			rep_okey=ADD_CON(rnomer,tnomer,rid)	&& отвечает также за добавление всего, что внутри для текущего RID
		OTHERWISE
			rep_okey=ADD_STR(rnomer,rztype,IIF(SEEK(tnomer,"_rtftables","k1"),ALLTRIM(_rtftables.ALINOW),m.alias_in))
		ENDCASE
		IF m.rep_okey<=0
			EXIT
		ENDIF
	ENDSCAN
	USE IN (m.tbl_alia)
RETURN m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION GET_RAZDKOL	&& получение количества независимых разделов в шаблоне
	LOCAL razd_kol,razd_con
	razd_kol=0
	razd_con=0
	SELECT _rtfreport
	SCAN FOR INLIST(obtype,2,10,11)		&& контейнеры и таблицы
		razd_con=ICASE(obtype=10,1,obtype=11,0,m.razd_con)
		DO CASE
		CASE obtype=10					&& начинается контейнер
			razd_kol=m.razd_kol+1
		CASE obtype=2 AND m.razd_con=0	&& начинается таблица, при условии, что она не в контейнере
			razd_kol=m.razd_kol+1
		ENDCASE
	ENDSCAN
RETURN m.razd_kol
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION ADD_CON	&& добавление контейнера
LPARAMETERS t_rnomer,t_anomer,t_rid
* t_rnomer 	- номер раздела
* t_anomer 	- номер алиаса
* t_rid		- ID раздела текущего контейнера
*--------------------------------------------------------------------------------------------
	LOCAL tbl__ali,tbl__key,ali_now,tbl__ord,tbl__des,rep_okey,key_data,ali_con
	=SEEK(m.t_anomer,"_rtftables","k1")
	tbl__ali=ALLTRIM(_rtftables.ALINOW)
	tbl__key=ALLTRIM(_rtftables.ALIKEY)
	tbl__ord=ALLTRIM(_rtftables.ALIORD)
	tbl__des=_rtftables.ALIDES
	ali_now=GET_REPALIAS("[CON]")	&& алиас с данными по контейнеру для цикла
	ali_con=GET_REPALIAS("[RZD]")	&& алиас с разделами для обработки
	tbl__key=IIF(EMPTY(m.tbl__key),"1=1",GET_FUNCONV(m.tbl__key))
	tbl__ord=IIF(EMPTY(m.tbl__ord),"1",m.tbl__ord)
*--------------------------------------------------------------------------------------------
	TEXT TO tempusl NOSHOW TEXTMERGE PRETEXT 7
		SELECT <<m.tbl__ord>> AS order_fld,* ;
		FROM <<m.tbl__ali>> ;
		ORDER BY 1 <<IIF(m.tbl__des=1,"DESC","")>> ;
		INTO CURSOR <<m.ali_now>> READWRITE
	ENDTEXT
	rep_okey=1
	TRY 
		=EXECSCRIPT(m.tempusl)
	CATCH
		rep_okey=0
		rep_errs='Не удалось получить данные для отчета!'
	ENDTRY
	IF m.rep_okey=1
		=RUN_SHET(1,0)				&& инициализация счетчиков по контейнеру
		SELECT * FROM _rtfreport WHERE rodrid=m.t_rid AND INLIST(obtype,2,7) INTO CURSOR (m.ali_con) READWRITE
*--------------------------------------------------------------------------------------------
* Формирование % выполнения
*--------------------------------------------------------------------------------------------
		proc_lvl=1					&& уровень 1-контейнер, 2-группа, 3-строка
		proc_all=con_all			&& всего шагов для текущего proc_rzd
		proc_now=0					&& текущий шаг %
		proc_kol=0					&& кол-во %
		proc_rzd=m.proc_rzd+1		&& раздел
		SELECT (m.ali_now)
		SCAN
			=RUN_SHET(1,1)			&& отработка счетчиков по контейнеру
			proc_now=m.proc_now+1	&& текущий шаг %
			=SHOW_PROC()			&& показ % выполнения
*--------------------------------------------------------------------------------------------
* Формирование заголовка контейнера
*--------------------------------------------------------------------------------------------
			IF m.rep_okey=1
				rep_okey=ADD_STR(m.t_rnomer,10,m.ali_now)
			ENDIF
*--------------------------------------------------------------------------------------------
			SELECT (m.ali_now)
			TRY 
				key_data=EVALUATE(m.tbl__key)	&& ключевое значение для выборки данных из таблицы
			CATCH
				rep_okey=0
				rep_errs='Неверно задано ключевое выражение при описании контейнера!'
			ENDTRY
			IF m.rep_okey=1
				SELECT (m.ali_con)	&& верхний уровень в контейнере - начало и конец таблиц
				SCAN
					DO CASE
					CASE obtype=2
						rep_okey=ADD_TBL(rnomer,tnomer,grnext,grpend,m.key_data,m.ali_now)	&& отвечает также за добавление 3,4,5,6
					OTHERWISE
						rep_okey=ADD_STR(rnomer,rztype,m.ali_now)
					ENDCASE
					IF m.rep_okey<=0
						EXIT
					ENDIF
				ENDSCAN
			ENDIF
			IF rep_okey#1
				EXIT
			ENDIF
		ENDSCAN
	ENDIF
*--------------------------------------------------------------------------------------------
	IF USED(m.ali_con)
		USE IN (m.ali_con)
	ENDIF
	IF USED(m.ali_now)
		USE IN (m.ali_now)
	ENDIF
RETURN m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION ADD_TBL	&& добавление таблицы
LPARAMETERS t_rnomer,t_anomer,t_grnext,t_tblend,t_keydata,t_keyalia
* t_rnomer 	- номер раздела
* t_anomer 	- номер алиаса
* t_grnext	- номер раздела группы таблицы
* t_tblend	- номер раздела подвала таблицы
* t_keydata	- ключевое значение для выборки данных из таблицы
* t_keyalia	- алиас с данными для получения значения ключа
*--------------------------------------------------------------------------------------------
	LOCAL rep_okey,tbl__ali,ali__grp,ali__now,tbl__add,ali__dat,tbl__dtl,grp_head
	=SEEK(m.t_anomer,"_rtftables","k1")
	tbl__ali=ALLTRIM(_rtftables.ALINOW)
	ali__now=GET_REPALIAS("[TBL]")
	ali__grp=GET_REPALIAS("[GZ1]")
	ali__dat=GET_REPALIAS("[GR1]")
	tbl__add=_rtftables.ALIADD
*--------------------------------------------------------------------------------------------
* Получение курсоров данных таблицы и заголовков групп
*--------------------------------------------------------------------------------------------
	rep_okey=GET_TBLDATA(m.t_anomer,m.t_keydata,m.t_keyalia)
*--------------------------------------------------------------------------------------------
* Формирование заголовка таблицы
*--------------------------------------------------------------------------------------------
	IF m.rep_okey=1
		=RUN_SHET(2,0)	&& инициализация счетчиков по таблице
		=RUN_SHET(2,1)	&& отработка счетчиков по таблице
		IF m.tbl_all>0 OR m.tbl__add=1	&& если есть хоть 1 запись или указано выдавать и пустую
			rep_okey=ADD_STR(m.t_rnomer,2,m.tbl__ali)	&& заголовок таблицы
			IF m.rep_okey=1
				IF SEEK(STR(m.t_anomer,10)+STR(4,2),"_rtfreport","k3")	&& ищем раздел для detail этой таблицы
					tbl__dtl=_rtfreport.rnomer		&& раздел detail
				ENDIF
				IF m.t_grnext>0		&& есть группы у этой таблицы
					rep_okey=GET_GRPTITL(m.t_anomer,1)				&& курсор с заголовками для группы 1 уровня
*--------------------------------------------------------------------------------------------
* Формирование % выполнения
*--------------------------------------------------------------------------------------------
					IF m.rep_okey=1
						IF INLIST(m.proc_lvl,0,2) AND RECCOUNT(m.ali__grp)>1	&& всего групп у таблицы>1
							proc_lvl=2								&& уровень 1-контейнер, 2-группа, 3-строка
							proc_all=RECCOUNT(m.ali__grp)			&& всего шагов для текущего proc_rzd
							proc_now=0								&& текущий шаг %
							proc_kol=0								&& кол-во %
							proc_rzd=m.proc_rzd+1					&& раздел
						ENDIF
*--------------------------------------------------------------------------------------------
* Формирование групп таблицы
*--------------------------------------------------------------------------------------------
						=RUN_SHET(3,0)				&& инициализация счетчиков по группе 1 уровня
						SELECT (m.ali__grp)
						SCAN
							rep_okey=GET_GRPDATA(m.t_anomer,1,grp_dat)	&& курсор с данными для группы 1 уровня
							IF m.rep_okey=1
								=RUN_SHET(3,1)						&& отработка счетчиков по группе 1 уровня
								DO CASE
								CASE m.proc_lvl=2
									proc_now=m.proc_now+1			&& текущий шаг %
									=SHOW_PROC()					&& показ % выполнения
								CASE INLIST(m.proc_lvl,0,3)
									proc_lvl=3						&& уровень 1-контейнер, 2-группа, 3-строка
									proc_all=RECCOUNT(m.ali__now)	&& всего шагов для текущего proc_rzd
									proc_now=0						&& текущий шаг %
									proc_kol=0						&& кол-во %
									proc_rzd=m.proc_rzd+1			&& раздел
								ENDCASE
								rep_okey=ADD_GRP(m.t_anomer,1,m.ali__dat,m.t_grnext,m.tbl__dtl)	&& для каждой группы по текущей таблице
							ENDIF
							IF m.rep_okey#1
								EXIT
							ENDIF
						ENDSCAN
					ENDIF
*--------------------------------------------------------------------------------------------
* Формирование строчек таблицы
*--------------------------------------------------------------------------------------------
				ELSE
					IF INLIST(m.proc_lvl,0,3)
						proc_lvl=3						&& уровень 1-контейнер, 2-группа, 3-строка
						proc_all=RECCOUNT(m.ali__now)	&& всего шагов для текущего proc_rzd
						proc_now=0						&& текущий шаг %
						proc_kol=0						&& кол-во %
						proc_rzd=m.proc_rzd+1			&& раздел
					ENDIF
					rep_okey=ADD_STRALIA(m.ali__now,m.tbl__dtl)
				ENDIF
			ENDIF
*--------------------------------------------------------------------------------------------
* Формирование подвала таблицы
*--------------------------------------------------------------------------------------------
			IF m.rep_okey=1 AND !EMPTY(m.t_tblend)
				rep_okey=ADD_STR(m.t_tblend,6,m.tbl__ali)
			ENDIF
		ENDIF
	ENDIF
*--------------------------------------------------------------------------------------------
	IF USED(m.ali__dat)
		USE IN (m.ali__dat)
	ENDIF
	IF USED(m.ali__grp)
		USE IN (m.ali__grp)
	ENDIF
	IF USED(m.ali__now)
		USE IN (m.ali__now)
	ENDIF
RETURN m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION ADD_GRP	&& добавление группы
LPARAMETERS t_anomer,grp_level,grp_alias,grp_head,tbl__dtl
* t_anomer 	- номер алиаса
* grp_level	- уровень вложенности
* grp_alias - алиас с данными 
* grp_head	- номер раздела головы группы
* tbl__dtl	- номер раздела DETAIL таблицы
*--------------------------------------------------------------------------------------------
	LOCAL rep_okey,ali__dat,grp__ttl,grp__end,grp__nxt
	ali__dat=GET_REPALIAS("[GR"+ALLTRIM(STR(m.grp_level+1))+"]")
	grp__ttl=GET_REPALIAS("[GZ"+ALLTRIM(STR(m.grp_level+1))+"]")
*--------------------------------------------------------------------------------------------
* Формирование головы группы
*--------------------------------------------------------------------------------------------
	=SEEK(m.grp_head,"_rtfreport","k5")
	grp__end=_rtfreport.grpend	&& RID хвоста группы
	grp__nxt=_rtfreport.grnext	&& RID подгруппы
	rep_okey=ADD_STR(m.grp_head,3,m.grp_alias)
	IF m.rep_okey=1
*--------------------------------------------------------------------------------------------
* Формирование подгрупп группы
*--------------------------------------------------------------------------------------------
		IF m.grp__nxt>0		&& есть подгруппы
			rep_okey=GET_GRPTITL(m.t_anomer,m.grp_level+1)					&& курсор с заголовками для группы N+1 уровня
			=RUN_SHET(3+m.grp_level,0)										&& инициализация счетчиков по группе N+1 уровня
			SELECT (m.grp__ttl)
			SCAN
				rep_okey=GET_GRPDATA(m.t_anomer,m.grp_level+1,grp_dat)		&& курсор с данными для группы N+1 уровня
				IF m.rep_okey=1
					=RUN_SHET(3+m.grp_level,1)								&& отработка счетчиков по группе N+1 уровня
					rep_okey=ADD_GRP(m.t_anomer,m.grp_level+1,m.ali__dat,m.grp__nxt,m.tbl__dtl)	&& для каждой группы по текущей таблице
				ENDIF
				IF m.rep_okey#1
					EXIT
				ENDIF
			ENDSCAN
*--------------------------------------------------------------------------------------------
* Формирование строчек группы
*--------------------------------------------------------------------------------------------
		ELSE
			rep_okey=ADD_STRALIA(m.grp_alias,m.tbl__dtl)
		ENDIF
	ENDIF
*--------------------------------------------------------------------------------------------
* Формирование подвала группы
*--------------------------------------------------------------------------------------------
	IF m.rep_okey=1 AND !EMPTY(m.grp__end)
		rep_okey=ADD_STR(m.grp__end,3,m.grp_alias)
	ENDIF
*--------------------------------------------------------------------------------------------
	IF USED(m.ali__dat)
		USE IN (m.ali__dat)	&& закрываем курсоры N+1 вложенности
	ENDIF
	IF USED(m.grp__ttl)
		USE IN (m.grp__ttl)	&& закрываем курсоры N+1 вложенности
	ENDIF
RETURN m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION ADD_STRALIA	&& добавление объектов по всем строкам алиаса
LPARAMETERS tek_alias,tbl__dtl
	SELECT (m.tek_alias)
	SCAN
		=RUN_SHET(9,1)				&& отработка счетчиков строк
		IF m.proc_lvl=3
			proc_now=m.proc_now+1	&& текущий шаг %
			=SHOW_PROC()			&& показ % выполнения
		ENDIF
		IF ADD_STR(m.tbl__dtl,4,m.tek_alias)#1	&& для каждой строки по текущей группе
			RETURN 0
		ENDIF
	ENDSCAN
RETURN 1
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION ADD_STR	&& добавление объектов по разделу
LPARAMETERS t_rnomer,t_rztype,t_alias
* t_rnomer 	- номер раздела
* t_rztype	- тип раздела
* t_alias	- surs с данными
*--------------------------------------------------------------------------------------------
	LOCAL i,err_now,f_ret
	PRIVATE tmp_name,tmp_func,ali_func,tmp_fusr,tmp_case,tmp_cusl,tmp_crun,tmp_fend,tmp_fout,znh_now,znh_val,znh_con,tmp_code
	tmp_case=0	&& ID CASE, объекты которого будут добавлены
	SELECT _rtfreport
	SCAN FOR rnomer=m.t_rnomer
		DO CASE
		CASE obkolv=1	&& управляющие теги
	  		f_ret = FWRITE(m.f_out,beetw_text)  && пишем в вых. файл
       		IF m.f_ret<0
       			rep_errs='Ошибка записи в выходной файл!'
	          	RETURN -1
	        ENDIF
		CASE obtype=12 	&& ENDPAGE
			IF !EMPTY(objusl)               && есть условие применения
            	IF !EMPTY(m.t_alias)
                	SELECT (m.t_alias)
                ENDIF
				TRY 
					tmp_crun=IIF(EVALUATE(ALLTRIM(_rtfreport.objusl)),1,0)
				CATCH
					tmp_crun=0		&& ошибка задания условия будет проигнорирована так, как будто условие не задавали вовсе
				ENDTRY
				SELECT _rtfreport
				IF m.tmp_crun=1		&& условие выполнено
					f_ret = FWRITE(m.f_out,'\page \par '+beetw_text)  && пишем в вых. файл
				ELSE
					f_ret = FWRITE(m.f_out,beetw_text)  && пишем в вых. файл
				ENDIF
			ELSE
		  		f_ret = FWRITE(m.f_out,IIF(RECNO(m.t_alias)<RECCOUNT(m.t_alias),'\page \par ','')+beetw_text)  && пишем в вых. файл
	  		ENDIF
       		IF m.f_ret<0
       			rep_errs='Ошибка записи в выходной файл!'
	          	RETURN -1
	        ENDIF
		CASE m.tmp_case=0 AND INLIST(obtype,13,14)	&& CASE,OTHERWISE, заходим вычислить ID CASE, который будет отрабатывать
			tmp_crun=1		&& 1-выводить этот CASE
			IF obtype=13	&& для CASE вычисляем выражение, OTHERWISE проскочит полюбому
				tmp_cusl=ALLTRIM(SUBSTR(_rtfreport.f_name,AT("=",_rtfreport.f_name)+1))	&& условие CASE
				tmp_cusl=GET_FUNCONV(m.tmp_cusl)
				IF !EMPTY(m.t_alias)
					SELECT (m.t_alias)
				ENDIF
				TRY 
					tmp_crun=IIF(EVALUATE(m.tmp_cusl),1,0)
				CATCH
					tmp_crun=0
				ENDTRY
				SELECT _rtfreport
			ENDIF
			IF m.tmp_crun=1
				tmp_case=_rtfreport.caseid		&& признак выполнения CASE
		  		f_ret = FWRITE(m.f_out,beetw_text)  && пишем в вых. файл
	       		IF m.f_ret<0
	       			rep_errs='Ошибка записи в выходной файл!'
		          	RETURN -1
		        ENDIF
			ENDIF
		CASE obtype=15	&& ENDCASE
			tmp_case=0
	  		f_ret = FWRITE(m.f_out,beetw_text)  && пишем в вых. файл
       		IF m.f_ret<0
       			rep_errs='Ошибка записи в выходной файл!'
	          	RETURN -1
	        ENDIF
		CASE !EMPTY(_rtfreport.caseid) AND _rtfreport.caseid#m.tmp_case	&& объекты включены в CASE с невыполненным условием
			LOOP
		OTHERWISE
			tmp_name=ALLTRIM(_rtfreport.f_name)
			IF LEFT(m.tmp_name,1)=="&" AND SEEK(VAL(SUBSTR(m.tmp_name,2)),"_rtfvables","k1")	&& нашли эту подстановку
				tmp_name=ALLTRIM(_rtfvables.f_name)
				tmp_func=UPPER(ALLTRIM(IIF(!EMPTY(_rtfreport.func_txt),_rtfreport.func_txt,_rtfvables.func_txt)))
				ali_func=UPPER(ALLTRIM(IIF(!EMPTY(_rtfreport.func_ali),_rtfreport.func_ali,_rtfvables.func_ali)))
				tmp_fusr=UPPER(ALLTRIM(IIF(!EMPTY(_rtfreport.func_usr),_rtfreport.func_usr,_rtfvables.func_usr)))
				tmp_fend=UPPER(ALLTRIM(IIF(!EMPTY(_rtfreport.func_end),_rtfreport.func_end,_rtfvables.func_end)))
				tmp_fout=UPPER(ALLTRIM(IIF(!EMPTY(_rtfreport.func_out),_rtfreport.func_out,_rtfvables.func_out)))
				tmp_code=IIF(!EMPTY(_rtfreport.code_txt),_rtfreport.code_txt,_rtfvables.code_txt)
			ELSE
				tmp_func=UPPER(ALLTRIM(_rtfreport.func_txt))
				ali_func=UPPER(ALLTRIM(_rtfreport.func_ali))
				tmp_fusr=UPPER(ALLTRIM(_rtfreport.func_usr))
				tmp_fend=UPPER(ALLTRIM(_rtfreport.func_end))
				tmp_fout=UPPER(ALLTRIM(_rtfreport.func_out))
				tmp_code=_rtfreport.code_txt
			ENDIF
			IF VARTYPE(m.t_alias)="C" AND !EMPTY(m.t_alias)
				SELECT (m.t_alias)
				ali_func=IIF(!EMPTY(m.ali_func),m.ali_func,m.t_alias)
			ENDIF
			err_now=0
			znh_now=''
			IF !EMPTY(m.t_alias)
				tmp_recn=IIF(EOF(m.t_alias),0,RECNO(m.t_alias))	&& запоминается текущая запись SURC курсора
			ENDIF
*--------------------------------------------------------------------------------------------
* Попытка получения значения
*--------------------------------------------------------------------------------------------
			TRY 
				IF EMPTY(m.tmp_func)
					IF !EMPTY(m.ali_func)
						SELECT (m.ali_func)
					ENDIF
					IF EOF()	&& проверяем, чтобы не было EOF() при обработке переменной
						GO BOTTOM
					ENDIF
					znh_now=EVALUATE(m.tmp_name)
				ELSE
					DO CASE
					CASE m.tmp_func=="SUM"	&& требуется посчитать по текущей таблице
						CALCULATE SUM(&tmp_name) TO znh_now IN (m.ali_func)
					CASE m.tmp_func=="MAX"	&& требуется посчитать MAX по текущей таблице
						CALCULATE MAX(&tmp_name) TO znh_now IN (m.ali_func)
					CASE m.tmp_func=="MIN"	&& требуется посчитать MIN по текущей таблице
						CALCULATE MIN(&tmp_name) TO znh_now IN (m.ali_func)
					CASE m.tmp_func=="CNT"	&& требуется посчитать кол-во по текущей таблице
						CALCULATE CNT(&tmp_name) TO znh_now IN (m.ali_func)
					CASE m.tmp_func=="AVG"	&& требуется посчитать среднее по текущей таблице
						CALCULATE AVG(&tmp_name) TO znh_now IN (m.ali_func)
					OTHERWISE
						err_now=1
					ENDCASE
				ENDIF
				znh_val=m.znh_now	&& запоминается вычисленное значение для использования во внешних ф-х
				IF !EMPTY(m.tmp_fusr)
					DO CASE
					CASE m.tmp_fusr=="DAT" AND INLIST(VARTYPE(m.znh_now),"D","T")
						znh_now=REP_DATAPROP(m.znh_now)
					CASE m.tmp_fusr=="TDT" AND VARTYPE(m.znh_now)="T"
						znh_now=TTOD(m.znh_now)
					CASE m.tmp_fusr=="PN1" AND INLIST(VARTYPE(m.znh_now),"D","T","C")
						znh_now=REP_PERNAME(m.znh_now)
					CASE m.tmp_fusr=="PN2" AND INLIST(VARTYPE(m.znh_now),"D","T")
						znh_now=REP_PERNAME(m.znh_now,"P")
					CASE m.tmp_fusr=="PN3" AND INLIST(VARTYPE(m.znh_now),"D","T")
						znh_now=REP_PERNAME(m.znh_now,"Q")
					CASE m.tmp_fusr=="PN4" AND INLIST(VARTYPE(m.znh_now),"D","T")
						znh_now=REP_PERNAME(m.znh_now,"H")
					CASE m.tmp_fusr=="KOL" AND VARTYPE(m.znh_now)="N"
						znh_now=REP_NUM_PROP(m.znh_now,1)
					CASE m.tmp_fusr=="RUB" AND VARTYPE(m.znh_now)="N"
						znh_now=REP_NUM_PROP(m.znh_now)
					CASE m.tmp_fusr=="INT" AND VARTYPE(m.znh_now)="N"
						znh_now=INT(m.znh_now)
					CASE m.tmp_fusr=="DEC" AND VARTYPE(m.znh_now)="N"
						znh_now=MOD(m.znh_now,1)
					CASE m.tmp_fusr=="RD0" AND VARTYPE(m.znh_now)="N"
						znh_now=ROUND(m.znh_now,0)
					CASE m.tmp_fusr=="RD1" AND VARTYPE(m.znh_now)="N"
						znh_now=ROUND(m.znh_now,1)
					CASE m.tmp_fusr=="RD2" AND VARTYPE(m.znh_now)="N"
						znh_now=ROUND(m.znh_now,2)
					CASE m.tmp_fusr=="RD3" AND VARTYPE(m.znh_now)="N"
						znh_now=ROUND(m.znh_now,3)
					CASE m.tmp_fusr=="IMG" AND VARTYPE(m.znh_now)="C"
						IF FILE(m.znh_now)	&& если есть этот файл
							DO CASE
							CASE UPPER(JUSTEXT(m.znh_now))=="PNG"
								znh_now="{\pict\pngblip "+STRCONV(FILETOSTR(m.znh_now),15)+" }"
							CASE UPPER(JUSTEXT(m.znh_now))=="JPG"
								znh_now="{\pict\jpegblip "+STRCONV(FILETOSTR(m.znh_now),15)+" }"
							ENDCASE
						ENDIF
					CASE m.tmp_fusr=="DIA" AND VARTYPE(m.znh_now)="C"
						IF LEFT(m.znh_now,6)=="ERROR:"
							tmp_fusr=''		&& обнуляем признак картинки, чтобы показать текст ошибки
						ELSE
							znh_now="{\pict\pngblip "+STRCONV(m.znh_now,15)+" }"
						ENDIF
					CASE m.tmp_fusr=="PAR" AND VARTYPE(m.znh_now)="C"	&& Актуально только для RTF
						znh_now=STRTRAN(m.znh_now,CHR(13),"{\par }")
					ENDCASE
				ENDIF
				znh_con=m.znh_now	&& запоминается вычисленное и преобразованное значение для использования во внешних ф-х
			CATCH TO goto_error
				err_now=1
			ENDTRY
			IF !EMPTY(m.t_alias) AND !EMPTY(m.tmp_recn)
				GO m.tmp_recn IN (m.t_alias)
			ENDIF
*--------------------------------------------------------------------------------------------
			IF m.err_now=1
				znh_now=ALLTRIM(_rtfreport.f_name)
			ELSE
				DO CASE
				CASE VARTYPE(m.znh_now)="C"
					DO CASE
					CASE m.tmp_fend=="HEX"
						znh_now=ENCODE_SYMBOLS(m.znh_now)
					CASE m.tmp_fusr=="IMG" OR m.tmp_fusr=="DIA"
						DO CASE
						CASE m.tmp_fend=="RM1"
							znh_now="{\pict\brdrs"+SUBSTR(m.znh_now,7)
						CASE m.tmp_fend=="RM2"
							znh_now="{\pict\brdrsh"+SUBSTR(m.znh_now,7)
						CASE m.tmp_fend=="RM3"
							znh_now="{\pict\brdrdb"+SUBSTR(m.znh_now,7)
						CASE m.tmp_fend=="ML5"	&& масштабирование (уменьшение) картинки на 50%
							znh_now="{\pict\picscalex50\picscaley50"+SUBSTR(m.znh_now,7)
						ENDCASE
					OTHERWISE
						m.znh_now=ALLTRIM(m.znh_now)
					ENDCASE
				CASE VARTYPE(m.znh_now)="N"
					DO CASE
					CASE (m.tmp_fend=="BLK" OR m.tmp_fend=="BLZ") AND m.znh_now=0	&& одна из ф-й BLANK ZERO
						znh_now=''
					CASE m.tmp_fend=="RAZ" OR m.tmp_fend=="BLZ"
						znh_now=NUM_RAZDEL(m.znh_now)
					CASE m.tmp_fend=="NUM"
						znh_now=ALLTRIM(CHRTRAN(PADL(m.znh_now,30),".",","))
					OTHERWISE
						m.znh_now=PADL(m.znh_now,30)
					ENDCASE
				CASE VARTYPE(m.znh_now)="D"
					m.znh_now=DTOC(m.znh_now)
				CASE VARTYPE(m.znh_now)="T"
					m.znh_now=TTOC(m.znh_now)
				CASE VARTYPE(m.znh_now)="L"
					DO CASE
					CASE m.tmp_fend=="LRU"
						m.znh_now=IIF(m.znh_now,"ДА","НЕТ")
					OTHERWISE
						m.znh_now=IIF(m.znh_now,"TRUE","FALSE")
					ENDCASE
				ENDCASE
*--------------------------------------------------------------------------------------------
* Пользовательская внешняя функция
*--------------------------------------------------------------------------------------------
				IF !EMPTY(m.tmp_fout)
					tmp_fout=IIF("ZNH_NOW"$m.tmp_fout OR "ZNH_VAL"$m.tmp_fout OR "ZNH_CON"$m.tmp_fout,m.tmp_fout,m.tmp_fout+"(m.znh_val)")	&& добавляем параметр со значением переменной
					TRY 
						znh_now=EVALUATE(m.tmp_fout)
						znh_now=IIF(VARTYPE(m.znh_now)#"C","",m.znh_now)	&& проверка, чтобы там снаружи не накосячили с типом возврата
					CATCH
						znh_now=m.tmp_fout	&& в случае ошибки показываем виновника торжества в отчете
					ENDTRY
				ENDIF
*--------------------------------------------------------------------------------------------
* Кодировка
*--------------------------------------------------------------------------------------------
				DO CASE
				CASE !EMPTY(m.tmp_code)		&& указана перекодировка поля
					znh_now=STRCONV(ALLTRIM(m.znh_now),m.tmp_code)
				CASE !EMPTY(m.reps_cod)		&& тотальная перекодировка файла
					znh_now=STRCONV(ALLTRIM(m.znh_now),m.reps_cod)
				ENDCASE
*--------------------------------------------------------------------------------------------
			ENDIF
			SELECT _rtfreport
	  		f_ret = FWRITE(m.f_out,ALLTRIM(m.znh_now)+beetw_text)  && пишем в вых. файл
       		IF m.f_ret<0
       			rep_errs='Ошибка записи в выходной файл!'
	          	RETURN -1
	        ENDIF
		ENDCASE
	ENDSCAN
RETURN 1
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION GET_TBLDATA	&& получение курсора данных для таблицы
LPARAMETERS t_anomer,t_keydata,t_keyalia
* t_anomer 	- номер алиаса
* t_keydata	- ключевое значение для выборки данных из таблицы
* t_keyalia	- алиас с данными для получения значения ключа
*--------------------------------------------------------------------------------------------
	LOCAL i,tbl__ali,tbl__key,tbl__usl,tbl__ord,tbl__des,ali__now,rep_okey,tbl__utp
	PRIVATE key_data
	=SEEK(m.t_anomer,"_rtftables","k1")
	tbl__ali=ALLTRIM(_rtftables.ALINOW)
	tbl__key=ALLTRIM(_rtftables.ALIKEY)
	tbl__usl=ALLTRIM(_rtftables.ALIUSL)
	tbl__ord=ALLTRIM(_rtftables.ALIORD)
	tbl__utp=_rtftables.ALIUTP
	tbl__des=_rtftables.ALIDES
	ali__now=GET_REPALIAS("[TBL]")
	tbl__ord=IIF(EMPTY(m.tbl__ord),"1",m.tbl__ord)
	tbl__key=GET_FUNCONV(m.tbl__key)
	tbl__usl=GET_FUNCONV(m.tbl__usl)
	rep_okey=1
	TRY 
		DO CASE
		CASE EMPTY(m.tbl__usl)
			tbl__usl=1
			key_data=1
		CASE !EMPTY(m.tbl__key) AND !EMPTY(m.t_keyalia)
			SELECT (m.t_keyalia)
			key_data=EVALUATE(m.tbl__key)	&& получаем ключевое значение в алиасе контейнера
		CASE VARTYPE(m.t_keydata)#"L"
			key_data=m.t_keydata			&& ключевое значение для выборки данных из таблицы берется из контейнера
		CASE !EMPTY(m.tbl__usl)				&& условие задано в шаблоне
			tbl__usl=m.tbl__usl
			key_data=.T.
		OTHERWISE
			tbl__usl=1
			key_data=1
		ENDCASE
	CATCH
		rep_okey=0
		rep_errs='Неверно задано ключевое выражение при описании таблицы!'
	ENDTRY
*--------------------------------------------------------------------------------------------
* Получение курсора данных таблицы
*--------------------------------------------------------------------------------------------
	IF m.tbl__utp=0	&& выборка по равенству
		TEXT TO tempusl NOSHOW TEXTMERGE PRETEXT 7
			SELECT <<m.tbl__ord>> AS order_fld,* ;
			FROM <<m.tbl__ali>> ;
			WHERE ;
				(<<m.tbl__usl>>)=m.key_data ;
			ORDER BY 1 <<IIF(m.tbl__des=1,"DESC","")>> ;
			INTO CURSOR <<m.ali__now>> READWRITE
		ENDTEXT
	ELSE			&& выборка по списку
		TEXT TO tempusl NOSHOW TEXTMERGE PRETEXT 7
			SELECT <<m.tbl__ord>> AS order_fld,* ;
			FROM <<m.tbl__ali>> ;
			WHERE ;
				<<m.tbl__usl>> IN (<<m.key_data>>) ;
			ORDER BY 1 <<IIF(m.tbl__des=1,"DESC","")>> ;
			INTO CURSOR <<m.ali__now>> READWRITE
		ENDTEXT
	ENDIF
	IF m.rep_okey=1
		TRY 
			=EXECSCRIPT(m.tempusl)
		CATCH
			rep_okey=0
			rep_errs='Неверно заданы ключ или условие при описании таблицы!'
		ENDTRY
	ENDIF
RETURN m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION GET_GRPTITL	&& получение курсора группы заданного уровня
LPARAMETERS t_anomer,grp_level
	LOCAL rep_okey
	PRIVATE grp__zapr,grp__func,grp__tbls,grp__alia
	=SEEK(m.t_anomer,"_rtftables","k1")
	grp__func=ALLTRIM(EVALUATE("_rtftables.GR"+ALLTRIM(STR(m.grp_level))+"NOW"))
	grp__tbls=GET_REPALIAS(IIF(m.grp_level=1,"[TBL]","[GR"+ALLTRIM(STR(m.grp_level-1))+"]"))
	grp__alia=GET_REPALIAS("[GZ"+ALLTRIM(STR(m.grp_level))+"]")
	IF EMPTY(m.grp__func) AND m.grp_level>1
		RETURN 1
	ENDIF
	grp__func=IIF(EMPTY(m.grp__func),"1",m.grp__func)
*--------------------------------------------------------------------------------------------
* Получение курсора групп
*--------------------------------------------------------------------------------------------
	TEXT TO grp__zapr NOSHOW TEXTMERGE PRETEXT 7
		SELECT DISTINCT ;
			<<m.grp__func>> AS grp_dat ;
		FROM <<m.grp__tbls>> ;
		INTO CURSOR <<m.grp__alia>> READWRITE
	ENDTEXT
	rep_okey=1
	TRY 
		=EXECSCRIPT(m.grp__zapr)
	CATCH
		rep_okey=0
		rep_errs='Неверно задано выражение группы '+ALLTRIM(STR(m.grp_level))+' при описании таблицы!'
	ENDTRY
RETURN m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION GET_GRPDATA	&& получение курсора группы заданного уровня
LPARAMETERS t_anomer,grp_level,grp_keydt
	LOCAL rep_okey
	PRIVATE grp__zapr,grp__func,grp__tbls,grp__alia,t_grpnow
	=SEEK(m.t_anomer,"_rtftables","k1")
	grp__func=ALLTRIM(EVALUATE("_rtftables.GR"+ALLTRIM(STR(m.grp_level))+"NOW"))
	grp__tbls=GET_REPALIAS(IIF(m.grp_level=1,"[TBL]","[GR"+ALLTRIM(STR(m.grp_level-1))+"]"))	&& сурс уровнем выше
	grp__alia=GET_REPALIAS("[GR"+ALLTRIM(STR(m.grp_level))+"]")
	IF EMPTY(m.grp__func) AND m.grp_level>1
		RETURN 1
	ENDIF
	grp__func=IIF(EMPTY(m.grp__func),"1",m.grp__func)
*--------------------------------------------------------------------------------------------
* Получение курсора групп
*--------------------------------------------------------------------------------------------
	t_grpnow=m.grp_keydt
	TEXT TO grp__zapr NOSHOW TEXTMERGE PRETEXT 7
		SELECT * ;
		FROM <<m.grp__tbls>> ;
		WHERE ;
			<<m.grp__func>>=m.t_grpnow ;
		INTO CURSOR <<m.grp__alia>> READWRITE
	ENDTEXT
	rep_okey=1
	TRY 
		=EXECSCRIPT(m.grp__zapr)
	CATCH
		rep_okey=0
		rep_errs='Неверно задано выражение группы '+ALLTRIM(STR(m.grp_level))+' при описании таблицы!'
	ENDTRY
RETURN m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION RUN_SHET	&& отработка всех счетчиков
LPARAMETERS sh_level,sh_metod
* sh_level - уровень вложенности
*	1-контейнер, 
*	2-таблица, 
*	3-группа 1 уровня, 
*	4-группа 2 уровня, 
*	5-группа 3 уровня, 
*	6-группа 4 уровня, 
*	7-группа 5 уровня, 
*	8-группа 6 уровня, 
*	9-строка
* sh_metod - 0 - инициализация, 1-выполнение
*--------------------------------------------------------------------------------------------
*	 1 rep_con - сквозной номер контейнера с начала отчета
*	 2 rep_tbl - сквозной номер таблицы с начала отчета
*	 3 rep_gr1 - сквозной номер группы 1 уровня с начала отчета
*	 4 rep_gr2 - сквозной номер группы 2 уровня с начала отчета
*	 5 rep_gr3 - сквозной номер группы 3 уровня с начала отчета
*	 6 rep_gr4 - сквозной номер группы 4 уровня с начала отчета
*	 7 rep_gr5 - сквозной номер группы 5 уровня с начала отчета
*	 8 rep_gr6 - сквозной номер группы 6 уровня с начала отчета
*	 9 rep_str - сквозной номер строки с начала отчета
*--------------------------------------------------------------------------------------------
*	10 con_all - всего строк в контейнере
*	11 con_now - текущая строка контейнера
*	12 con_str - сквозной номер строки с начала контейнера
*	13 con_tbl - сквозной номер таблицы с начала контейнера
*	14 con_gr1 - сквозной номер группы 1 уровня с начала контейнера
*	15 con_gr2 - сквозной номер группы 2 уровня с начала контейнера
*	16 con_gr3 - сквозной номер группы 3 уровня с начала контейнера
*	17 con_gr4 - сквозной номер группы 4 уровня с начала контейнера
*	18 con_gr5 - сквозной номер группы 5 уровня с начала контейнера
*	19 con_gr6 - сквозной номер группы 6 уровня с начала контейнера
*--------------------------------------------------------------------------------------------
*	20 tbl_all - всего строк в таблице
*	21 tbl_now - текущая строка таблицы (Не использовать!)
*	22 tbl_str - сквозной номер строки с начала таблицы
*	23 tbl_gr1 - сквозной номер группы 1 уровня с начала таблицы
*	24 tbl_gr2 - сквозной номер группы 2 уровня с начала таблицы
*	25 tbl_gr3 - сквозной номер группы 3 уровня с начала таблицы
*	26 tbl_gr4 - сквозной номер группы 4 уровня с начала таблицы
*	27 tbl_gr5 - сквозной номер группы 5 уровня с начала таблицы
*	28 tbl_gr6 - сквозной номер группы 6 уровня с начала таблицы
*	29 tbl_kol - Всего групп 1 уровня у этой таблицы
*--------------------------------------------------------------------------------------------
*	30 gr1_all - всего строк в группе 1 уровня
*	31 gr1_now - текущая группа 1 уровня
*	32 gr1_str - сквозной номер строки с начала группы 1 уровня
*	33 gr1_gr2 - сквозной номер группы 2 уровня с начала групп 1 уровня
*	34 gr1_gr3 - сквозной номер группы 3 уровня с начала групп 1 уровня
*	35 gr1_gr4 - сквозной номер группы 4 уровня с начала групп 1 уровня
*	36 gr1_gr5 - сквозной номер группы 5 уровня с начала групп 1 уровня
*	37 gr1_gr6 - сквозной номер группы 6 уровня с начала групп 1 уровня
*	38 gr1_kol - Всего групп 2 уровня у группы 1 уровня
*	39 gr1_tek - номер строки текущей группы 1 уровня
*--------------------------------------------------------------------------------------------
*	40 gr2_all - всего строк в группе 2 уровня
*	41 gr2_now - текущая группа 2 уровня
*	42 gr2_str - сквозной номер строки с начала группы 2 уровня
*	43 gr2_gr3 - сквозной номер группы 3 уровня с начала групп 2 уровня
*	44 gr2_gr4 - сквозной номер группы 4 уровня с начала групп 2 уровня
*	45 gr2_gr5 - сквозной номер группы 5 уровня с начала групп 2 уровня
*	46 gr2_gr6 - сквозной номер группы 6 уровня с начала групп 2 уровня
*	47 gr2_kol - Всего групп 3 уровня у группы 2 уровня
*	48 gr2_tek - номер строки текущей группы 2 уровня
*--------------------------------------------------------------------------------------------
*	49 gr3_all - всего строк в группе 3 уровня
*	50 gr3_now - текущая группа 3 уровня
*	51 gr3_str - сквозной номер строки с начала группы 3 уровня
*	52 gr3_gr4 - сквозной номер группы 4 уровня с начала групп 3 уровня
*	53 gr3_gr5 - сквозной номер группы 5 уровня с начала групп 3 уровня
*	54 gr3_gr6 - сквозной номер группы 6 уровня с начала групп 3 уровня
*	55 gr3_kol - Всего групп 4 уровня у группы 3 уровня
*	56 gr3_tek - номер строки текущей группы 3 уровня
*--------------------------------------------------------------------------------------------
*	57 gr4_all - всего строк в группе 4 уровня
*	58 gr4_now - текущая группа 4 уровня
*	59 gr4_str - сквозной номер строки с начала группы 4 уровня
*	60 gr4_gr5 - сквозной номер группы 5 уровня с начала групп 4 уровня
*	61 gr4_gr6 - сквозной номер группы 6 уровня с начала групп 4 уровня
*	62 gr4_kol - Всего групп 5 уровня у группы 4 уровня
*	63 gr4_tek - номер строки текущей группы 4 уровня
*--------------------------------------------------------------------------------------------
*	64 gr5_all - всего строк в группе 5 уровня
*	65 gr5_now - текущая группа 5 уровня
*	66 gr5_str - сквозной номер строк с начала группы 5 уровня
*	67 gr5_gr6 - сквозной номер группы 6 уровня с начала групп 5 уровня
*	68 gr5_kol - Всего групп 6 уровня у группы 5 уровня
*	69 gr5_tek - номер строки текущей группы 5 уровня
*--------------------------------------------------------------------------------------------
*	70 gr6_all - всего строк в группе 6 уровня
*	71 gr6_now - текущая группа 6 уровня
*	72 gr6_tek - номер строки текущей группы 6 уровня
*--------------------------------------------------------------------------------------------
	LOCAL i
	IF m.sh_metod=0
*--------------------------------------------------------------------------------------------
* Инициализация счетчиков контейнера, таблицы
*--------------------------------------------------------------------------------------------
		DO CASE
		CASE m.sh_level=2		&& таблица
			rep_shet(20)=RECCOUNT(GET_REPALIAS("[TBL]"))
		CASE m.sh_level=1		&& контейнер
			rep_shet(10)=RECCOUNT(GET_REPALIAS("[CON]"))
		ENDCASE
*--------------------------------------------------------------------------------------------
* Сброс подчиненных счетчиков
*--------------------------------------------------------------------------------------------
		FOR i=1 TO 72
			DO CASE
			CASE m.sh_level<=8 AND INLIST(m.i,71,72)						&& группа 6 уровня
				rep_shet(m.i)=0
			CASE m.sh_level<=7 AND INLIST(m.i,65,66,67,69)					&& группа 5 уровня
				rep_shet(m.i)=0
			CASE m.sh_level<=6 AND INLIST(m.i,58,59,60,61,63)				&& группа 4 уровня
				rep_shet(m.i)=0
			CASE m.sh_level<=5 AND INLIST(m.i,50,51,52,53,54,56)			&& группа 3 уровня
				rep_shet(m.i)=0
			CASE m.sh_level<=4 AND INLIST(m.i,41,42,43,44,45,46,48)			&& группа 2 уровня
				rep_shet(m.i)=0
			CASE m.sh_level<=3 AND INLIST(m.i,31,32,33,34,35,36,37,39)		&& группа 1 уровня
				rep_shet(m.i)=0
			CASE m.sh_level<=2 AND INLIST(m.i,21,22,23,24,25,26,27,28)		&& таблица
				rep_shet(m.i)=0
			CASE m.sh_level<=1 AND INLIST(m.i,11,12,13,14,15,16,17,18,19)	&& контейнер
				rep_shet(m.i)=0
			ENDCASE
		ENDFOR
	ELSE
*--------------------------------------------------------------------------------------------
* Отработка счетчиков объектов
*--------------------------------------------------------------------------------------------
		IF BETWEEN(m.sh_level,1,8)
			FOR i=1 TO 72
				DO CASE
				CASE m.sh_level=8 AND INLIST(m.i,8,19,28,37,46,54,61,67)		&& группа 6 уровня
					rep_shet(m.i)=rep_shet(m.i)+1
				CASE m.sh_level=7 AND INLIST(m.i,7,18,27,36,45,53,60)			&& группа 5 уровня
					rep_shet(m.i)=rep_shet(m.i)+1
				CASE m.sh_level=6 AND INLIST(m.i,6,17,26,35,44,52)				&& группа 4 уровня
					rep_shet(m.i)=rep_shet(m.i)+1
				CASE m.sh_level=5 AND INLIST(m.i,5,16,25,34,43)			 		&& группа 3 уровня
					rep_shet(m.i)=rep_shet(m.i)+1
				CASE m.sh_level=4 AND INLIST(m.i,4,15,24,33)					&& группа 2 уровня
					rep_shet(m.i)=rep_shet(m.i)+1
				CASE m.sh_level=3 AND INLIST(m.i,3,14,23)						&& группа 1 уровня
					rep_shet(m.i)=rep_shet(m.i)+1
				CASE m.sh_level=2 AND INLIST(m.i,2,13)							&& таблица
					rep_shet(m.i)=rep_shet(m.i)+1
				CASE m.sh_level=1 AND INLIST(m.i,1)								&& контейнер
					rep_shet(m.i)=rep_shet(m.i)+1
				ENDCASE
			ENDFOR
		ENDIF
*--------------------------------------------------------------------------------------------
* Отработка счетчиков текущих строк объектов по уровню
*--------------------------------------------------------------------------------------------
		DO CASE
		CASE m.sh_level=9 						&& DETAIL
			rep_shet( 9)=rep_shet(9)+1
			rep_shet(12)=rep_shet(12)+IIF(rep_shet(11)#0,1,0)	&& CON

			rep_shet(22)=rep_shet(22)+IIF(rep_shet(20)#0,1,0)	&& TBL
			
			rep_shet(32)=rep_shet(32)+IIF(rep_shet(31)#0,1,0)	&& GR1
			rep_shet(39)=rep_shet(39)+IIF(rep_shet(31)#0,1,0)	&& GR1
			
			rep_shet(42)=rep_shet(42)+IIF(rep_shet(41)#0,1,0)	&& GR2
			rep_shet(48)=rep_shet(48)+IIF(rep_shet(41)#0,1,0)	&& GR2

			rep_shet(51)=rep_shet(51)+IIF(rep_shet(50)#0,1,0)	&& GR3
			rep_shet(56)=rep_shet(56)+IIF(rep_shet(50)#0,1,0)	&& GR3
			
			rep_shet(59)=rep_shet(59)+IIF(rep_shet(58)#0,1,0)	&& GR4
			rep_shet(63)=rep_shet(63)+IIF(rep_shet(58)#0,1,0)	&& GR4
			
			rep_shet(66)=rep_shet(66)+IIF(rep_shet(65)#0,1,0)	&& GR5
			rep_shet(69)=rep_shet(69)+IIF(rep_shet(65)#0,1,0)	&& GR5
			
			rep_shet(72)=rep_shet(72)+IIF(rep_shet(71)#0,1,0)	&& GR6
		CASE m.sh_level=8 						&& группа 6 уровня
			rep_shet(71)=rep_shet(71)+1
			rep_shet(72)=0
			rep_shet(70)=RECCOUNT(GET_REPALIAS("[GR6]"))
			rep_shet(68)=RECCOUNT(GET_REPALIAS("[GZ6]"))
		CASE m.sh_level=7 						&& группа 5 уровня
			rep_shet(65)=rep_shet(65)+1
			rep_shet(69)=0
			rep_shet(64)=RECCOUNT(GET_REPALIAS("[GR5]"))
			rep_shet(62)=RECCOUNT(GET_REPALIAS("[GZ5]"))
		CASE m.sh_level=6 						&& группа 4 уровня
			rep_shet(58)=rep_shet(58)+1
			rep_shet(63)=0
			rep_shet(57)=RECCOUNT(GET_REPALIAS("[GR4]"))
			rep_shet(55)=RECCOUNT(GET_REPALIAS("[GZ4]"))
		CASE m.sh_level=5 						&& группа 3 уровня
			rep_shet(50)=rep_shet(50)+1
			rep_shet(56)=0
			rep_shet(49)=RECCOUNT(GET_REPALIAS("[GR3]"))
			rep_shet(47)=RECCOUNT(GET_REPALIAS("[GZ3]"))
		CASE m.sh_level=4 						&& группа 2 уровня
			rep_shet(41)=rep_shet(41)+1
			rep_shet(48)=0
			rep_shet(40)=RECCOUNT(GET_REPALIAS("[GR2]"))
			rep_shet(38)=RECCOUNT(GET_REPALIAS("[GZ2]"))
		CASE m.sh_level=3 						&& группа 1 уровня
			rep_shet(31)=rep_shet(31)+1
			rep_shet(39)=0
			rep_shet(30)=RECCOUNT(GET_REPALIAS("[GR1]"))
			rep_shet(29)=RECCOUNT(GET_REPALIAS("[GZ1]"))
		CASE m.sh_level=2 						&& таблица
			rep_shet(21)=rep_shet(21)+1
		CASE m.sh_level=1 						&& контейнер
			rep_shet(11)=rep_shet(11)+1
		ENDCASE
	ENDIF
*--------------------------------------------------------------------------------------------
* Формирование переменных
*--------------------------------------------------------------------------------------------
	rep_con=rep_shet( 1)
	rep_tbl=rep_shet( 2)
	rep_gr1=rep_shet( 3)
	rep_gr2=rep_shet( 4)
	rep_gr3=rep_shet( 5)
	rep_gr4=rep_shet( 6)
	rep_gr5=rep_shet( 7)
	rep_gr6=rep_shet( 8)
	rep_str=rep_shet( 9)
	con_all=rep_shet(10)
	con_now=rep_shet(11)
	con_str=rep_shet(12)
	con_tbl=rep_shet(13)
	con_gr1=rep_shet(14)
	con_gr2=rep_shet(15)
	con_gr3=rep_shet(16)
	con_gr4=rep_shet(17)
	con_gr5=rep_shet(18)
	con_gr6=rep_shet(19)
	tbl_all=rep_shet(20)
	tbl_now=rep_shet(21)	&& (Не использовать!)
	tbl_str=rep_shet(22)
	tbl_gr1=rep_shet(23)
	tbl_gr2=rep_shet(24)
	tbl_gr3=rep_shet(25)
	tbl_gr4=rep_shet(26)
	tbl_gr5=rep_shet(27)
	tbl_gr6=rep_shet(28)
	tbl_kol=rep_shet(29)
	gr1_all=rep_shet(30)
	gr1_now=rep_shet(31)
	gr1_str=rep_shet(32)
	gr1_gr2=rep_shet(33)
	gr1_gr3=rep_shet(34)
	gr1_gr4=rep_shet(35)
	gr1_gr5=rep_shet(36)
	gr1_gr6=rep_shet(37)
	gr1_kol=rep_shet(38)
	gr1_tek=rep_shet(39)
	gr2_all=rep_shet(40)
	gr2_now=rep_shet(41)
	gr2_str=rep_shet(42)
	gr2_gr3=rep_shet(43)
	gr2_gr4=rep_shet(44)
	gr2_gr5=rep_shet(45)
	gr2_gr6=rep_shet(46)
	gr2_kol=rep_shet(47)
	gr2_tek=rep_shet(48)
	gr3_all=rep_shet(49)
	gr3_now=rep_shet(50)
	gr3_str=rep_shet(51)
	gr3_gr4=rep_shet(52)
	gr3_gr5=rep_shet(53)
	gr3_gr6=rep_shet(54)
	gr3_kol=rep_shet(55)
	gr3_tek=rep_shet(56)
	gr4_all=rep_shet(57)
	gr4_now=rep_shet(58)
	gr4_str=rep_shet(59)
	gr4_gr5=rep_shet(60)
	gr4_gr6=rep_shet(61)
	gr4_kol=rep_shet(62)
	gr4_tek=rep_shet(63)
	gr5_all=rep_shet(64)
	gr5_now=rep_shet(65)
	gr5_str=rep_shet(66)
	gr5_gr6=rep_shet(67)
	gr5_kol=rep_shet(68)
	gr5_tek=rep_shet(69)
	gr6_all=rep_shet(70)
	gr6_now=rep_shet(71)
	gr6_tek=rep_shet(72)
RETURN
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION SHOW_PROC	&& вывод % выполнения формирования отчета
LOCAL proc_new
	proc_new=ROUND((m.proc_now/m.proc_all)*100,0)
	IF m.proc_new#m.proc_kol	&& кол-во %
		proc_kol=m.proc_new
		WAIT WINDOW IIF("[HIDE]"$UPPER(m.rep_config),"","Идет формирование отчета: "+ALLTRIM(STR(m.proc_kol))+" %"+CHR(13)+"Раздел "+ALLTRIM(STR(m.proc_rzd))+" из "+ALLTRIM(STR(m.proc_glv))) NOWAIT NOCLEAR
	ENDIF
RETURN
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION GET_FUNCONV	&& Конвертация подстановок поля
LPARAMETERS get_data
	get_data=STRTRAN(m.get_data,"[CON]",GET_REPALIAS("[CON]"),-1,-1,1)
	get_data=STRTRAN(m.get_data,"[TBL]",GET_REPALIAS("[TBL]"),-1,-1,1)
	get_data=STRTRAN(m.get_data,"[GR1]",GET_REPALIAS("[GR1]"),-1,-1,1)
	get_data=STRTRAN(m.get_data,"[GR2]",GET_REPALIAS("[GR2]"),-1,-1,1)
	get_data=STRTRAN(m.get_data,"[GR3]",GET_REPALIAS("[GR3]"),-1,-1,1)
	get_data=STRTRAN(m.get_data,"[GR4]",GET_REPALIAS("[GR4]"),-1,-1,1)
	get_data=STRTRAN(m.get_data,"[GR5]",GET_REPALIAS("[GR5]"),-1,-1,1)
	get_data=STRTRAN(m.get_data,"[GR6]",GET_REPALIAS("[GR6]"),-1,-1,1)
RETURN ALLTRIM(m.get_data)
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION GET_REPALIAS	&& Получение алиасов курсоров отчета
LPARAMETERS get_data
LOCAL ret_data
	ret_data=''
	DO CASE
	CASE m.get_data=="[CON]"
		ret_data="_dat_con"
	CASE m.get_data=="[TBL]"
		ret_data="_dat_tbl"
	CASE m.get_data=="[GR1]"
		ret_data="_dat_gr1"
	CASE m.get_data=="[GZ1]"
		ret_data="_zag_gr1"
	CASE m.get_data=="[GR2]"
		ret_data="_dat_gr2"
	CASE m.get_data=="[GZ2]"
		ret_data="_zag_gr2"
	CASE m.get_data=="[GR3]"
		ret_data="_dat_gr3"
	CASE m.get_data=="[GZ3]"
		ret_data="_zag_gr3"
	CASE m.get_data=="[GR4]"
		ret_data="_dat_gr4"
	CASE m.get_data=="[GZ4]"
		ret_data="_zag_gr4"
	CASE m.get_data=="[GR5]"
		ret_data="_dat_gr5"
	CASE m.get_data=="[GZ5]"
		ret_data="_zag_gr5"
	CASE m.get_data=="[GR6]"
		ret_data="_dat_gr6"
	CASE m.get_data=="[GZ6]"
		ret_data="_zag_gr6"
	CASE m.get_data=="[REP]"
		ret_data="_rtf_rep"
	CASE m.get_data=="[RZD]"
		ret_data="_rtf_con"
	ENDCASE
RETURN m.ret_data
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION READ_RTF	&& загрузка шаблона как структуры
PARAMETERS f_shabl
PRIVATE f_body,l_body
*--------------------------------------------------------------------------------------------
* Открытие шаблона и начало работы
*--------------------------------------------------------------------------------------------
	IF FILE(m.f_shabl)
		f_body=FILETOSTR(m.f_shabl)
		l_body=LEN(m.f_body)
		IF !EMPTY(m.l_body) && открылся
			DO CASE
			CASE !EMPTY(JUSTSTEM(m.f_othet))	&& задан путь и имя файла отчета
				f_othet=m.f_othet
			CASE !EMPTY(JUSTPATH(m.f_othet))	&& задан только путь 
				f_othet=ADDBS(JUSTPATH(m.f_othet))+JUSTSTEM(m.f_shabl)+'.rtf'
			OTHERWISE
				f_othet=ADDBS(JUSTPATH(m.f_shabl))+JUSTSTEM(m.f_shabl)+'_out.rtf'	&& берем файл шаблона и кладем рядом результат с добавкой _out в имени файла
			ENDCASE
		ELSE
			rep_errs='Не удалось открыть файл шаблона!'
			RETURN -1
		ENDIF
	ELSE
		rep_errs='Не найден файл шаблона!'
		RETURN -1
	ENDIF
*--------------------------------------------------------------------------------------------
* создаем таблицу структуры отчета
*--------------------------------------------------------------------------------------------
	CREATE CURSOR _rtftables ( ;
							TNOMER N(10), ;		&& ID алиаса
							ALINOW C(20), ;		&& алиас
							ALIADD N(1), ;		&& 0 - не добавлять пустые (по умолчанию), 1 - добавлять всегда
							ALIORD C(250), ;	&& выражение сортировки
							ALIDES N(1), ;		&& 1 - сортировка DESCENDING
							ALIKEY C(250), ;	&& выражение ключа контейнера, в который входит таблица
							ALIUSL C(250), ;	&& выражение условия
							ALIUTP N(1), ;		&& Тип условия 0-=,1-$
							GR1NOW C(250), ;	&& выражение группировки 1 уровня
							GR2NOW C(250), ;	&& выражение группировки 2 уровня
							GR3NOW C(250), ;	&& выражение группировки 3 уровня
							GR4NOW C(250), ;	&& выражение группировки 4 уровня
							GR5NOW C(250), ;	&& выражение группировки 5 уровня
							GR6NOW C(250))		&& выражение группировки 6 уровня
	INDEX ON TNOMER TAG K1 ADDITIVE
	CREATE CURSOR _rtfreport ( ;
							RID N(10), ;		&& ID строки
							RNOMER N(10), ;		&& ID раздела
							RZTYPE N(2), ;		&& Тип раздела
							OBTYPE N(2), ;		&& Тип объекта
							OBKOLV N(10), ;		&& Порядковый номер объекта в разделе
							TNOMER N(10), ;		&& ID алиаса
							RODRID N(10), ;		&& ID строки родительского объекта
							CASEID N(10), ;		&& ID строки родительского CASE
							GRNEXT N(10), ;		&& ID раздела подгруппы для этой группы или таблицы
							GRPEND N(10), ;		&& ID раздела подвала для этой группы или таблицы
							FUNC_TXT C(3), ;	&& функция суммирования
							FUNC_USR C(3), ;	&& функция преобразования
							FUNC_END C(3), ;	&& функция окончательного форматирования
							FUNC_OUT C(250), ;	&& внешняя функция окончательного форматирования (выполняется после всего)
							FUNC_ALI C(20), ;	&& алиас выполнения функции суммирования или вычисления значения
							CODE_TXT N(2), ;	&& Перекодировка значения
							F_NAME C(250), ;	&& распознанный текст в скобках []
							OBJUSL C(250), ;	&& выражение условия добавления объекта
						   	BEETW_TEXT M)		&& тело файла
	INDEX ON RID TAG K1 ADDITIVE
	INDEX ON STR(TNOMER,10)+STR(OBTYPE,2) TAG K3 ADDITIVE
	INDEX ON RNOMER TAG K5 ADDITIVE
	SET ORDER TO K1
	CREATE CURSOR _rtfvables ( ;
							VID N(10), ;		&& ID строки
							FUNC_TXT C(3), ;	&& функция суммирования
							FUNC_USR C(3), ;	&& функция преобразования
							FUNC_END C(3), ;	&& функция окончательного форматирования
							FUNC_OUT C(250), ;	&& внешняя функция окончательного форматирования (выполняется после всего)
							FUNC_ALI C(20), ;	&& алиас выполнения функции суммирования или вычисления значения
							CODE_TXT N(2), ;	&& Перекодировка значения
							F_NAME C(250))		&& распознанный текст в скобках []
	INDEX ON VID TAG K1 ADDITIVE
*--------------------------------------------------------------------------------------------
* Заполняем структуру
*--------------------------------------------------------------------------------------------
	DIMENSION tag_mass(100)	&& массив стек открытых тегов
	DIMENSION ali_mass(100)	&& массив стек алиасов
	LOCAL fld_kus
	PRIVATE tag_kolv,ali_kolv,rzd_nomer,rzd_type,rzd_oldt,rzd_kolvo,obj_type,obj_count,obj_body,tbl_count,tmp_body,ret_block
	tag_kolv=0	&& кол-во управляющих тегов в массиве tag_mass
	ali_kolv=0	&& кол-во алиасов в массиве ali_mass
	rzd_nomer=0	&& текущий № раздела
	rzd_type=8	&& текущий тип = постоянная часть отчета
	rzd_oldt=8	&& предыдущий тип для счетчика
	rzd_count=0	&& кол-во разделов
	rzd_kolvo=0	&& кол-во объектов в текущем разделе
	obj_type=0	&& тип объекта (1- поле или функция)
	obj_count=0	&& кол-во объектов всего (ID)
	obj_body=''	&& поле или функция
	tbl_count=0	&& кол-во таблиц всего (текущий ID для добавления)
	tmp_body=''	&& часть тела файла для записи
	ret_block=1	&& признак записи 1-прямо в файл, 0 - в tmp_body
	DO WHILE !EMPTY(m.f_body)
*--------------------------------------------------------------------------------------------
* Считываем кусок файла
*--------------------------------------------------------------------------------------------
		DO CASE
		CASE LEFT(m.f_body,1)="["							&& если слева "[" берем только 1 символ
			fld_kus = "["
		CASE AT("[",m.f_body)>0
			fld_kus = LEFT(m.f_body,AT("[",m.f_body)-1)		&& если есть "[" берем все до символа "["
		OTHERWISE
			fld_kus =m.f_body
		ENDCASE
		f_body=SUBSTR(m.f_body,LEN(m.fld_kus)+1)			&& удаляем ту часть, которую обработали
*--------------------------------------------------------------------------------------------
* Обрабатываем кусок
*--------------------------------------------------------------------------------------------
    	IF m.fld_kus='['
    		IF m.ret_block=1
    			=ADD_STRU()	&& добавление строки в структурный файл
			ENDIF
      		ret_block=REBLD_BLOK()
      		DO CASE
      		CASE m.ret_block=0	&& продолжить сканирование в файл
      			REPLACE BEETW_TEXT WITH _rtfreport.BEETW_TEXT+"[" IN _rtfreport
      		CASE m.ret_block=-1
		    	RETURN -1
		    OTHERWISE
   				f_body=SUBSTR(m.f_body,m.ret_block+1)	&& удаляем ту часть, которую обработали в REBLD_BLOK()
			    ret_block=1								&& предыдущий блок распознан - сканирование в m.tmp_body
      		ENDCASE
    	ELSE
			IF m.ret_block=0				&& продолжить сканирование в файл
      			REPLACE BEETW_TEXT WITH _rtfreport.BEETW_TEXT+m.fld_kus IN _rtfreport
			ELSE
	    		tmp_body=m.tmp_body+m.fld_kus
	    	ENDIF
    	ENDIF
	ENDDO
	=ADD_STRU()	&& добавление строки в структурный файл
*--------------------------------------------------------------------------------------------
* Проверяем кодировку
*--------------------------------------------------------------------------------------------
	=FONT_RECODE()	&& Функция перекодировки шрифтов
*--------------------------------------------------------------------------------------------
* Проверки алиасов
*--------------------------------------------------------------------------------------------
	SELECT _rtftables
	SCAN
		IF !USED(ALLTRIM(alinow))
			rep_errs='Не найден алиас '+ALLTRIM(alinow)+'!'
			RETURN -1
		ENDIF
	ENDSCAN
*--------------------------------------------------------------------------------------------
* Выковыриваем функции, причесываем поля
*--------------------------------------------------------------------------------------------
	LOCAL i,tmp_name,tmp_alia,tmp_func,tmp_rid,tmp_text,tmp_fusr,tmp_fend,tmp_rvar,tmp_fout,tmp_code
	SELECT _rtfreport
	SCAN FOR obtype=9
		tmp_name=ALLTRIM(f_name)
		tmp_alia=''
		tmp_func=''
		tmp_fusr=''
		tmp_fend=''
		tmp_fout=''
		tmp_rvar=0
		tmp_code=0
		FOR i=1 to 10
			tmp_text=UPPER(GETWORDNUM(m.tmp_name,1,":"))
			DO CASE
			CASE LEFT(m.tmp_text,6)=="REPVAR"			&& объявление подстановки
				IF _rtfreport.rztype#1	&& если не заголовок, подвал отчета
					rep_errs='Объявлена подстановка внутри контейнера или таблицы!'
					RETURN -1
				ENDIF
				tmp_rvar=VAL(SUBSTR(m.tmp_text,7))
				tmp_name=ALLTRIM(SUBSTR(m.tmp_name,AT(":",m.tmp_name)+1))	&& отсекаем ф-ю
			CASE LEN(m.tmp_text)=3 AND INLIST(m.tmp_text,"SUM","MAX","MIN","CNT","AVG")			&& функции подсчета
				tmp_func=m.tmp_text
				tmp_name=ALLTRIM(SUBSTR(m.tmp_name,AT(":",m.tmp_name)+1))	&& отсекаем ф-ю
			CASE LEN(m.tmp_text)=3 AND INLIST(m.tmp_text,"DAT","TDT","PN1","PN2","PN3","PN4","KOL","RUB","INT","DEC","RD0","RD1","RD2","RD3","IMG","DIA","PAR")		&& функции преобразования
				tmp_fusr=m.tmp_text
				tmp_name=ALLTRIM(SUBSTR(m.tmp_name,AT(":",m.tmp_name)+1))	&& отсекаем ф-ю
			CASE LEN(m.tmp_text)=3 AND INLIST(m.tmp_text,"CON","TBL","GR1","GR2","GR3","GR4","GR5","GR6")		&& ссылка на алиас
				tmp_alia=GET_REPALIAS("["+m.tmp_text+"]")
				tmp_name=ALLTRIM(SUBSTR(m.tmp_name,AT(":",m.tmp_name)+1))	&& отсекаем ф-ю
			CASE LEN(m.tmp_text)=3 AND INLIST(m.tmp_text,"HEX","RAZ","RM1","RM2","RM3","LRU","BLZ","BLK","ML5","NUM")		&& функции окончательного форматирования
				tmp_fend=m.tmp_text
				tmp_name=ALLTRIM(SUBSTR(m.tmp_name,AT(":",m.tmp_name)+1))	&& отсекаем ф-ю
			CASE LEFT(m.tmp_text,4)=="FUN="		&& пользовательская функция отображения данных
				tmp_fout=SUBSTR(m.tmp_text,5)
				tmp_name=ALLTRIM(SUBSTR(m.tmp_name,AT(":",m.tmp_name)+1))	&& отсекаем ф-ю
			CASE LEFT(m.tmp_text,4)=="COD="	&& перекодировка, заданная для этого поля
				tmp_code=VAL(SUBSTR(m.tmp_text,5))
				tmp_name=ALLTRIM(SUBSTR(m.tmp_name,AT(":",m.tmp_name)+1))	&& отсекаем ф-ю
			OTHERWISE
				EXIT
			ENDCASE
		ENDFOR
		tmp_name=GET_FUNCONV(m.tmp_name)
		IF m.tmp_rvar=0		&& переменная
			REPLACE FUNC_TXT WITH m.tmp_func,FUNC_USR WITH m.tmp_fusr,FUNC_ALI WITH m.tmp_alia,F_NAME WITH m.tmp_name,FUNC_END WITH m.tmp_fend, FUNC_OUT WITH m.tmp_fout, CODE_TXT WITH tmp_code
		ELSE				&& подстановка
			IF SEEK(m.tmp_rvar,"_rtfvables","k1")
				rep_errs='Объявлены две подстановки с одинаковыми ID='+ALLTRIM(STR(m.tmp_rvar))+'!'
				RETURN -1
			ENDIF		
			REPLACE F_NAME WITH "''"	&& переменная подстановка в тексте документа будет схлопнута
			INSERT INTO _rtfvables (VID,FUNC_TXT,FUNC_USR,FUNC_ALI,F_NAME,FUNC_END,FUNC_OUT,CODE_TXT) ;
			VALUES (m.tmp_rvar,m.tmp_func,m.tmp_fusr,m.tmp_alia,m.tmp_name,m.tmp_fend,m.tmp_fout,m.tmp_code)
		ENDIF
	ENDSCAN
*--------------------------------------------------------------------------------------------
* Заполняем поле ID родительского объекта (вложенность алиасов)
*--------------------------------------------------------------------------------------------
	tmp_rid=0
	SELECT _rtfreport
	SCAN
		DO CASE
		CASE obtype=10
			tmp_rid=rid
		CASE obtype=11
			tmp_rid=0
		OTHERWISE
			IF !EMPTY(m.tmp_rid)
				REPLACE RODRID WITH m.tmp_rid
			ENDIF
		ENDCASE
	ENDSCAN
*--------------------------------------------------------------------------------------------
* Проверяем, чтобы не было одинаковых алиасов у контейнера и вложенной таблицы
*--------------------------------------------------------------------------------------------
	SELECT _rtfreport
	SCAN FOR obtype=2 AND !EMPTY(rodrid)	&& таблицы
		tmp_alia=tnomer
		tmp_rid=rid
		=SEEK(rodrid,"_rtfreport","k1")
		IF m.tmp_alia=tnomer
			rep_errs='Одинаковые алиасы у контейнера и вложенной таблицы!'
			RETURN -1
		ENDIF		
		=SEEK(m.tmp_rid,"_rtfreport","k1")
	ENDSCAN
*--------------------------------------------------------------------------------------------
* Проверяем, чтобы каждая таблица имела DETAIL
*--------------------------------------------------------------------------------------------
	tmp_alia=0
	SELECT _rtfreport
	SCAN FOR INLIST(obtype,2,4)		&& таблицы и их DETAIL
		tmp_alia=m.tmp_alia+IIF(obtype=2,1,-1)
	ENDSCAN
	IF m.tmp_alia#0
		rep_errs='Проверьте наличие тега DETAIL у всех таблиц!'
		RETURN -1
	ENDIF		
*--------------------------------------------------------------------------------------------
* Проверяем, чтобы не было пересечений CASE с другими тегами и проставляем родительский CASEID 
*--------------------------------------------------------------------------------------------
	tmp_rid=0
	SELECT _rtfreport
	SCAN
		DO CASE
		CASE INLIST(obtype,13,14)
			tmp_rid=rid
		CASE INLIST(obtype,15)
			tmp_rid=0
		ENDCASE
		IF m.tmp_rid#0
			IF INLIST(obtype,1,2,3,4,5,6,7,8,10,11)	&& пересечение с другими тегами
				rep_errs='Проверьте тег CASE/ENDCASE он пересекается с другими тегами!'
				RETURN -1
			ENDIF
			REPLACE CASEID WITH m.tmp_rid
		ENDIF
	ENDSCAN
*--------------------------------------------------------------------------------------------
* Заполняем поля GRNEXT и GRPEND
*--------------------------------------------------------------------------------------------
	DIMENSION grp_rids(6)	&& RID хвостов
	grp_rids=0
	grp_kols=0				&& кол-во незанятых хвостов
	grp_next=0				&& следующая группа
	grp_detl=0				&& RID detail
	SELECT _rtfreport
	SET ORDER TO k1 DESCENDING
	SCAN FOR INLIST(obtype,2,5,3,6,7)		&& группы и их хвосты, таблицы и их ENDDETAILN и ENDALIAS
		DO CASE
		CASE INLIST(obtype,5,6)	&& хвост, ENDDETAIL
			grp_kols=m.grp_kols+1
			DIMENSION grp_rids(m.grp_kols)	&& RID хвостов
			grp_rids(m.grp_kols)=rnomer
		CASE INLIST(obtype,2,3)	&& таблица, группа
			IF !EMPTY(m.grp_next)
				REPLACE GRNEXT WITH m.grp_next
			ENDIF
			DO CASE
			CASE obtype=2 AND m.grp_kols>0			&& хвостов может на всех не хватить!
				REPLACE GRPEND WITH grp_rids(m.grp_kols)
				grp_kols=0
				grp_next=0
			CASE obtype=3
				IF m.grp_kols>1			&& хвостов может на всех не хватить!
					REPLACE GRPEND WITH grp_rids(m.grp_kols)
					grp_kols=m.grp_kols-1
				ENDIF
				grp_next=rnomer
			ENDCASE
		ENDCASE
	ENDSCAN
	SET ORDER TO k1
*--------------------------------------------------------------------------------------------
* Заполняем поле OBJUSL
*--------------------------------------------------------------------------------------------
	SELECT _rtfreport
	SCAN FOR INLIST(obtype,12)		&& ENDPAGE
		tmp_fld=UPPER(f_name)	&& убираем регистрозависимость из условия
		FOR i=1 TO GETWORDCOUNT(m.tmp_fld,"|")
			tbl_txt=ALLTRIM(GETWORDNUM(m.tmp_fld,m.i,"|"))
			tbl_dat=ALLTRIM(SUBSTR(m.tbl_txt,AT("=",m.tbl_txt)+1))
			IF UPPER(LEFT(CHRTRAN(m.tbl_txt," ",""),4))=="USL="
				REPLACE OBJUSL WITH m.tbl_dat
				LOOP
			ENDIF
		ENDFOR
	ENDSCAN
*--------------------------------------------------------------------------------------------
* Убираем лишние ENTER, оставшиеся после разбора строк со структурой
*--------------------------------------------------------------------------------------------
	SELECT _rtfreport
	SCAN FOR INLIST(obtype,1,2,3,4,5,6,7,8,10,11,12,13,14,15)		&& УПРАВЛЯЮЩИЕ ТЕГИ
		DO CASE
		CASE ASC(LEFT(beetw_text,1))=13 AND ASC(SUBSTR(beetw_text,2,1))=10
			REPLACE beetw_text WITH SUBSTR(beetw_text,3)
		CASE ASC(LEFT(beetw_text,1))=13
			REPLACE beetw_text WITH SUBSTR(beetw_text,2)
		ENDCASE
	ENDSCAN
*--------------------------------------------------------------------------------------------
* Проверяем, не нужно ли изменить тип значения для ячеек, имеющих признач числа
*--------------------------------------------------------------------------------------------
	IF "[EXCEL]"$UPPER(m.rep_config)
		SELECT RECNO() as izmnow FROM _rtfreport WHERE "NUM"$func_end INTO CURSOR _tmpreport READWRITE
		REPLACE ALL izmnow WITH izmnow-1
		SELECT _tmpreport
		SCAN
			GO _tmpreport.izmnow IN _rtfreport
			IF 'Type="String"'$_rtfreport.beetw_text
				REPLACE beetw_text WITH STRTRAN(_rtfreport.beetw_text,'Type="String"','Type="Number"',OCCURS('Type="String"',_rtfreport.beetw_text)) IN _rtfreport
			ENDIF
		ENDSCAN
		USE IN _tmpreport
	ENDIF
*--------------------------------------------------------------------------------------------
* Тотальная перекодировка файла
*--------------------------------------------------------------------------------------------
	IF m.reps_cod#0
		SELECT _rtfreport
		SCAN
			REPLACE beetw_text WITH STRCONV(beetw_text,m.reps_cod)
		ENDSCAN
	ENDIF
RETURN 1


*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION ADD_STRU	&& добавление строки в структурный файл
	obj_count=m.obj_count+1
	tbl_alias=IIF(m.ali_kolv=0,0,ali_mass(m.ali_kolv))
	IF m.rzd_type#m.rzd_oldt
		rzd_kolvo=1
		rzd_oldt=m.rzd_type
		rzd_count=m.rzd_count+1
	ELSE
		rzd_kolvo=m.rzd_kolvo+1
	ENDIF
	IF m.obj_type#9	&& если не переменная - убираем перевод строки
		tmp_body=STRTRAN(m.tmp_body,'\par ','',1,1,1)
	ENDIF
	INSERT INTO _rtfreport(RID,RNOMER,RZTYPE,OBTYPE,F_NAME,BEETW_TEXT,TNOMER,OBKOLV) ;
	VALUES(m.obj_count,m.rzd_count,m.rzd_type,m.obj_type,m.obj_body,m.tmp_body,m.tbl_alias,m.rzd_kolvo)
	tmp_body=''
RETURN 
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION FONT_RECODE	&& Функция перекодировки шрифтов
	LOCAL i,i1,j1,text_new
	SELECT _rtfreport
	=SEEK(1,"_rtfreport","k1")
	m.text_new=beetw_text
	FOR i=1 TO 3
		i1 = AT('fcharset', m.text_new,m.i)
		IF m.i1>0	&& найдены установки шрифтов
			i2 = AT('\', SUBSTR(m.text_new,m.i1))
			text_new=SUBSTR(m.text_new,1,m.i1-1)+"fcharset204"+SUBSTR(m.text_new,m.i1+m.i2-1)
		ENDIF
	ENDFOR
	REPLACE beetw_text WITH m.text_new
RETURN
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION REBLD_BLOK	&& Функция обработки поля
	LOCAL i,fld_txt,fld_teg,fld_txt1,fld_kus,kolskb,readpz,len_block
	LOCAL tbl__alia,tbl__key,tbl__usl,tbl__utp,tbl__ord,tbl__add,tbl__des
	fld_txt=''
	fld_kus=''
*--------------------------------------------------------------------------------------------
* считывает все, что находится до следующей закрывающей скобки с учетом того, что могут быть вложенные скобки []
*--------------------------------------------------------------------------------------------
	i=0
	DO WHILE .T.
		i=m.i+1
		fld_txt=LEFT(m.f_body,AT("]",m.f_body,m.i))				&& берем все до символа "]" включительно
		DO CASE
		CASE !EMPTY(m.fld_txt)
			IF OCCURS("]",m.fld_txt)-OCCURS("[",m.fld_txt)=1	&& закрывающих квадратных скобок на 1 больше
				EXIT
			ENDIF
		OTHERWISE
			fld_txt=m.f_body									&& берем все - не нашли закрываюшую квадратную скобку
			EXIT
		ENDCASE
	ENDDO
	len_block=LEN(m.fld_txt)									&& длина блока для удаления обработанной строки
	fld_txt=LEFT(m.fld_txt,LEN(m.fld_txt)-1)					&& убираем закрывающую квадратную скобку
*--------------------------------------------------------------------------------------------
* избавляемся от RTF в поле, если он там есть
*--------------------------------------------------------------------------------------------
	LOCAL cntrus,lenfld,rpos,rkod,rsymb
	fld_txt = CHRTRAN(m.fld_txt, CHR(13)+CHR(10),'')
	IF AT('}',m.fld_txt)>0 OR AT('{',m.fld_txt)>0 OR AT('\',m.fld_txt)>0
		cntrus=OCCURS("\'", m.fld_txt)  && кол-во русских символов в поле в формате RTF (hex-коды)
		IF m.cntrus>0  && если есть такие, то переводим их в буквы
     		FOR i = 1 to m.cntrus  && идем по всем русским кодам
				rpos = AT("\'", m.fld_txt)
				rkod = SUBSTR(m.fld_txt, m.rpos + 2,2)  && находим код
				rsymb = EVALUATE('CHR(0x' + m.rkod + ')')
				fld_txt = STUFF(m.fld_txt, m.rpos, 4, m.rsymb)
			ENDFOR
		ENDIF
		fld_txt = STRTRAN(m.fld_txt, '\rquote ',"'",-1,-1,1)  && заменяем RTF одиночной кавычки на символ
		fld_txt1 = m.fld_txt
		fld_txt=''
		lenfld = LEN(m.fld_txt1)
		FOR i=1 TO m.lenfld
			fld_kus = SUBSTR(m.fld_txt1,m.i,1)
			IF INLIST(m.fld_kus,'}','{','\')  && начало куска RTF
				DO WHILE m.i<=m.lenfld
					fld_kus = SUBSTR(m.fld_txt1,m.i,1)
					IF INLIST(m.fld_kus,'}','{',' ')
						EXIT
					ENDIF
					i = m.i + 1
				ENDDO
			ELSE
				fld_txt = m.fld_txt + m.fld_kus
			ENDIF
		ENDFOR 
	ENDIF 
*--------------------------------------------------------------------------------------------
* разбор названия
*--------------------------------------------------------------------------------------------
	fld_txt=CHRTRAN(ALLTRIM(m.fld_txt),"“”",'""')		&& с сохранением регистра
	fld_teg=UPPER(CHRTRAN(m.fld_txt," ",""))			&& без регистра и пробелов для обработки тегов
	IF m.rzd_type=8 AND LEFT(m.fld_teg,9)#"REP:START"	&& если обнаружен знак [ в постоянной части отчета
		RETURN 0										&& продолжаем сканирование как будто ничего не было
	ENDIF
	DO CASE
	CASE LEFT(m.fld_teg,9)=="REP:START"	&& начало отчета
		ret_tags=PROV_TAGS(1)
	CASE LEFT(m.fld_teg,8)=="REP:CON="	&& регистрация нового контейнера
		ret_tags=PROV_TAGS(10)
		IF m.ret_tags=1
			fld_txt=UPPER(m.fld_txt)	&& убираем регистрозависимость из индексов, условий и сортировок
			tbl_count=m.tbl_count+1
			tbl__alia=''
			tbl__key=''
			tbl__ord=''
			tbl__des=0
			FOR i=1 TO 10
				tbl_txt=ALLTRIM(GETWORDNUM(SUBSTR(m.fld_txt,5),m.i,"|"))
				tbl_dat=ALLTRIM(SUBSTR(m.tbl_txt,AT("=",m.tbl_txt)+1))
				IF LEFT(m.tbl_dat,1)=="&"
					TRY 
						tbl_dat=ALLTRIM(EVALUATE(SUBSTR(m.tbl_dat,2)))
					CATCH
						ret_tags=-1
						rep_errs='Неверно описан тег [CON] - нет переменной, содержащей настройки контейнера!'
					ENDTRY
					IF m.ret_tags=-1
						RETURN -1
					ENDIF
				ENDIF
				DO CASE
				CASE UPPER(LEFT(CHRTRAN(m.tbl_txt," ",""),4))=="CON="
					tbl__alia=m.tbl_dat
				CASE UPPER(LEFT(CHRTRAN(m.tbl_txt," ",""),4))=="KEY="
					tbl__key=m.tbl_dat
				CASE UPPER(LEFT(CHRTRAN(m.tbl_txt," ",""),4))=="ORD="
					IF UPPER(ALLTRIM(GETWORDNUM(m.tbl_dat,1,":")))=="DESC"
						tbl__des=1
						tbl__ord=ALLTRIM(SUBSTR(m.tbl_dat,AT(":",m.tbl_dat)+1))
					ELSE
						tbl__ord=m.tbl_dat
					ENDIF
				ENDCASE
			ENDFOR
			IF EMPTY(m.tbl__alia)
				ret_tags=0
			ELSE
				INSERT INTO _rtftables (TNOMER,ALINOW,ALIKEY,ALIORD,ALIDES) ;
				VALUES (m.tbl_count,m.tbl__alia,m.tbl__key,m.tbl__ord,m.tbl__des)
				ali_kolv=m.ali_kolv+1
				ali_mass(m.ali_kolv)=m.tbl_count	&& массив стек алиасов
			ENDIF
		ENDIF
	CASE LEFT(m.fld_teg,8)=="REP:ALI="	&& регистрация новой таблицы
		ret_tags=PROV_TAGS(2)
		IF m.ret_tags=1
			fld_txt=UPPER(m.fld_txt)	&& убираем регистрозависимость из индексов, условий и сортировок
			tbl_count=m.tbl_count+1
			tbl__alia=''
			tbl__key=''
			tbl__usl=''
			tbl__ord=''
			tbl__add=0
			tbl__des=0
			tbl__utp=0
			FOR i=1 TO 10
				tbl_txt=ALLTRIM(GETWORDNUM(SUBSTR(m.fld_txt,5),m.i,"|"))
				tbl_dat=ALLTRIM(SUBSTR(m.tbl_txt,AT("=",m.tbl_txt)+1))
				IF LEFT(m.tbl_dat,1)=="&"
					TRY 
						tbl_dat=ALLTRIM(EVALUATE(SUBSTR(m.tbl_dat,2)))
					CATCH
						ret_tags=-1
						rep_errs='Неверно описан тег [ALI] - нет переменной, содержащей настройки таблицы!'
					ENDTRY
					IF m.ret_tags=-1
						RETURN -1
					ENDIF
				ENDIF
				DO CASE
				CASE UPPER(LEFT(CHRTRAN(m.tbl_txt," ",""),4))=="ALI="
					tbl__alia=m.tbl_dat
				CASE UPPER(LEFT(CHRTRAN(m.tbl_txt," ",""),4))=="KEY="
					tbl__key=m.tbl_dat
				CASE UPPER(LEFT(CHRTRAN(m.tbl_txt," ",""),4))=="USL="
					tbl__usl=m.tbl_dat
				CASE UPPER(LEFT(CHRTRAN(m.tbl_txt," ",""),4))=="USL$"
					tbl__usl=ALLTRIM(SUBSTR(m.tbl_txt,AT("$",m.tbl_txt)+1))
					tbl__utp=1
				CASE UPPER(LEFT(CHRTRAN(m.tbl_txt," ",""),4))=="ORD="
					IF UPPER(ALLTRIM(GETWORDNUM(m.tbl_dat,1,":")))=="DESC"
						tbl__des=1
						tbl__ord=ALLTRIM(SUBSTR(m.tbl_dat,AT(":",m.tbl_dat)+1))
					ELSE
						tbl__ord=m.tbl_dat
					ENDIF
				CASE UPPER(LEFT(CHRTRAN(m.tbl_txt," ",""),4))=="ADD="
					tbl__add=VAL(m.tbl_dat)
				ENDCASE
			ENDFOR
			IF EMPTY(m.tbl__alia)
				ret_tags=0
			ELSE
				INSERT INTO _rtftables (TNOMER,ALINOW,ALIKEY,ALIUSL,ALIORD,ALIADD,ALIDES,ALIUTP) ;
				VALUES (m.tbl_count,m.tbl__alia,m.tbl__key,m.tbl__usl,m.tbl__ord,m.tbl__add,m.tbl__des,m.tbl__utp)
				ali_kolv=m.ali_kolv+1
				ali_mass(m.ali_kolv)=m.tbl_count	&& массив стек алиасов
			ENDIF
		ENDIF
	CASE LEFT(m.fld_teg,8)=="REP:GRP="	&& группировка по таблице
		ret_tags=PROV_TAGS(3)
		IF m.ret_tags=1
			LOCAL grp_find,grp_flds
			grp_find=0	&& количество открытых групп (глубина вложенности)
			FOR i=m.tag_kolv TO 1 STEP -1
				DO CASE
				CASE tag_mass(m.i)=2
					EXIT
				CASE tag_mass(m.i)=3
					grp_find=m.grp_find+1
				ENDCASE
			ENDFOR
			rzd_oldt=-1					&& сбрасываем тип предыдущего раздела, чтобы новая группа посчиталась с новым номером
			fld_txt=UPPER(m.fld_txt)	&& убираем регистрозависимость из индексов, условий и сортировок
			tbl_dat=ALLTRIM(SUBSTR(m.fld_txt,AT("=",m.fld_txt)+1))
			IF LEFT(m.tbl_dat,1)=="&"
				TRY 
					tbl_dat=ALLTRIM(EVALUATE(SUBSTR(m.tbl_dat,2)))
				CATCH
					ret_tags=-1
					rep_errs='Неверно описан тег [GRP] - нет переменной, содержащей настройки группы!'
				ENDTRY
				IF m.ret_tags=-1
					RETURN -1
				ENDIF
			ENDIF
			IF SEEK(ali_mass(m.ali_kolv),"_rtftables","k1")
				grp_flds="GR"+ALLTRIM(STR(m.grp_find))+"NOW"
				REPLACE &grp_flds WITH m.tbl_dat IN _rtftables
			ENDIF
		ENDIF
	CASE LEFT(m.fld_teg,10)=="REP:DETAIL"
		ret_tags=PROV_TAGS(4)
	CASE LEFT(m.fld_teg,13)=="REP:ENDDETAIL"
		ret_tags=PROV_TAGS(5)
	CASE LEFT(m.fld_teg,12)=="REP:ENDGROUP"
		ret_tags=PROV_TAGS(6)
		rzd_oldt=-1					&& сбрасываем тип предыдущего раздела, чтобы новый конец группы посчитался с новым номером
	CASE LEFT(m.fld_teg,12)=="REP:ENDALIAS"
		ret_tags=PROV_TAGS(7)
		IF m.ret_tags=1
			ali_mass(m.ali_kolv)=''
			ali_kolv=m.ali_kolv-1
		ENDIF
	CASE LEFT(m.fld_teg,10)=="REP:ENDCON"
		ret_tags=PROV_TAGS(11)
	CASE LEFT(m.fld_teg,9)=="REP:FINAL"
		ret_tags=PROV_TAGS(8)
	CASE LEFT(m.fld_teg,11)=="REP:ENDPAGE"
		ret_tags=PROV_TAGS(12)
	CASE LEFT(m.fld_teg,8)=="REP:CASE"
		ret_tags=PROV_TAGS(13)
	CASE LEFT(m.fld_teg,13)=="REP:OTHERWISE"
		ret_tags=PROV_TAGS(14)
	CASE LEFT(m.fld_teg,11)=="REP:ENDCASE"
		ret_tags=PROV_TAGS(15)
	OTHERWISE	&& поле или функция для подстановки
		ret_tags=PROV_TAGS(9)
	ENDCASE
	IF m.ret_tags=-1
		RETURN -1
	ENDIF
	obj_body=m.fld_txt
RETURN m.len_block
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION PROV_TAGS	&& отслеживание стека вложенности тегов отчета в массиве tag_mass
PARAMETERS tag_nomer
*  1 - Заголовок отчета
*  2 - Заголовок таблицы
*  3 - Заголовок группы
*  4 - Детайл
*  5 - Подвал группы
*  6 - Подвал таблицы
*  7 - Подпись отчета
*  8 - Постоянная часть отчета
*  9 - Поле или функция для подстановки
* 10 - Начало контейнера
* 11 - Конец контейнера
* 12 - Конец страницы
* 13 - Начало CASE
* 14 - Начало OTHERWISE
* 15 - Конец CASE
*--------------------------------------------------------------------------------------------
	LOCAL i,tbl_find,grp_find,dtl_find,con_find
	tbl_find=0	&& признак найденной таблицы
	grp_find=0	&& количество найденных групп
	dtl_find=0	&& признак найденной detail
	con_find=0	&& признак найденного контейнера
	FOR i=m.tag_kolv TO 1 STEP -1
		DO CASE
		CASE tag_mass(m.i)=10
			con_find=1
		CASE tag_mass(m.i)=2
			tbl_find=1
		CASE tag_mass(m.i)=3 AND m.tbl_find=0
			grp_find=m.grp_find+1
		CASE tag_mass(m.i)=4 AND m.tbl_find=0
			dtl_find=1
		ENDCASE
	ENDFOR
	DO CASE
	CASE INLIST(m.tag_nomer,1)	&& добавление Заголовок отчета
		IF ASCAN(tag_mass,m.tag_nomer)#0
			rep_errs='Повторно описан тег [Заголовок отчета]!'
			RETURN -1
		ENDIF
		tag_kolv=m.tag_kolv+1
		tag_mass(m.tag_kolv)=m.tag_nomer
	CASE INLIST(m.tag_nomer,2)	&& добавление Заголовок таблицы
		IF m.tbl_find=1 AND m.dtl_find=0	&& объявлена новая таблица без объявления DETAIL - добавляем
			tag_kolv=m.tag_kolv+1
			tag_mass(m.tag_kolv)=4
		ENDIF
		tag_kolv=m.tag_kolv+1
		tag_mass(m.tag_kolv)=m.tag_nomer
	CASE INLIST(m.tag_nomer,3)	&& добавление Заголовок группы
		DO CASE
		CASE m.dtl_find=1	&& найдена DETAIL 
			rep_errs='Неверно описан тег [Заголовок группы] - в DETAIL!'
			RETURN -1
		CASE m.grp_find=6	&& найдена группа
			rep_errs='Неверно описан тег [Заголовок группы] - превышена максимальная вложенность групп!'
			RETURN -1
		CASE m.tbl_find=0	&& не найдена таблица
			rep_errs='Неверно описан тег [Заголовок группы] - не найдена таблица!'
			RETURN -1
		ENDCASE
		tag_kolv=m.tag_kolv+1
		tag_mass(m.tag_kolv)=m.tag_nomer
	CASE INLIST(m.tag_nomer,4)	&& добавление Детайл
		DO CASE
		CASE m.dtl_find=1	&& найдена DETAIL 
			rep_errs='Повторно описан тег [DETAIL]!'
			RETURN -1
		CASE m.tbl_find=0	&& не найдена таблица
			rep_errs='Неверно описан тег [DETAIL] - не найдена таблица!'
			RETURN -1
		ENDCASE
		tag_kolv=m.tag_kolv+1
		tag_mass(m.tag_kolv)=m.tag_nomer
*--------------------------------------------------------------------------------------------
	CASE INLIST(m.tag_nomer,5)	&& закрытие тега DETAIL 
		DO CASE
		CASE m.dtl_find=0	&& не найдена DETAIL 
			rep_errs='Неверно описан тег [ENDDETAIL] - не найден открытый тег [DETAIL]!'
			RETURN -1
		CASE m.tbl_find=0	&& не найдена таблица
			rep_errs='Неверно описан тег [ENDDETAIL] - не найдена таблица!'
			RETURN -1
		ENDCASE
		tag_mass(m.tag_kolv)=0
		tag_kolv=m.tag_kolv-1
	CASE INLIST(m.tag_nomer,6)	&& закрытие тега группы
		DO CASE
		CASE m.grp_find=0	&& не найдена группа
			rep_errs='Неверно описан тег [ENDGROUP] - не найдена открытая группа!'
			RETURN -1
		CASE m.tbl_find=0	&& не найдена таблица
			rep_errs='Неверно описан тег [ENDGROUP] - не найдена таблица!'
			RETURN -1
		ENDCASE
		FOR i=1 TO 1+m.dtl_find		&& найдена DETAIL
			tag_mass(m.tag_kolv)=0	&& автозакрытие подчиненных тегов
			tag_kolv=m.tag_kolv-1
		ENDFOR
	CASE INLIST(m.tag_nomer,7)	&& закрытие тега таблицы
		DO CASE
		CASE m.tbl_find=0	&& не найдена таблица
			rep_errs='Неверно описан тег [ENDALIAS] - не найдена открытая таблица!'
			RETURN -1
		ENDCASE
		FOR i=1 TO 1+m.dtl_find+m.grp_find	&& найдена DETAIL или группа
			tag_mass(m.tag_kolv)=0			&& автозакрытие подчиненных тегов
			tag_kolv=m.tag_kolv-1
		ENDFOR
	CASE INLIST(m.tag_nomer,8)	&& закрытие Постоянная часть отчета
		DO CASE
		CASE m.con_find=1	&& найден контейнер
			rep_errs='Неверно описан тег [FINAL] - не закрыт тег контейнер!'
			RETURN -1
		ENDCASE
		tag_mass=0
		tag_kolv=0
	CASE INLIST(m.tag_nomer,9)	&& Поле или функция для подстановки
		IF ASCAN(tag_mass,1)=0	&& не открыт тег отчета
			rep_errs='Не открыт тег [START]!'
			RETURN -1
		ENDIF
	CASE INLIST(m.tag_nomer,10)	&& добавление контейнера
		DO CASE
		CASE m.dtl_find=1	&& найдена DETAIL 
			rep_errs='Неверно описан тег [CON] - найдена открытая DETAIL!'
			RETURN -1
		CASE m.grp_find#0	&& найдена группа
			rep_errs='Неверно описан тег [CON] - найдена открытая группа!'
			RETURN -1
		CASE m.tbl_find=1	&& Найдена таблица
			rep_errs='Неверно описан тег [CON] - найдена открытая таблица!'
			RETURN -1
		ENDCASE
		tag_kolv=m.tag_kolv+1
		tag_mass(m.tag_kolv)=m.tag_nomer
	CASE INLIST(m.tag_nomer,11)	&& закрытие контейнера
		DO CASE
		CASE m.con_find=0	&& НЕ найден контейнер
			rep_errs='Неверно описан тег [ENDCON] - не найден открытый контейнер!'
			RETURN -1
		CASE m.dtl_find=1	&& найдена DETAIL 
			rep_errs='Неверно описан тег [ENDCON] - найдена открытая DETAIL!'
			RETURN -1
		CASE m.grp_find#0	&& найдена группа
			rep_errs='Неверно описан тег [ENDCON] - найдена открытая группа!'
			RETURN -1
		CASE m.tbl_find=1	&& Найдена таблица
			rep_errs='Неверно описан тег [ENDCON] - найдена открытая таблица!'
			RETURN -1
		ENDCASE
		tag_mass(m.tag_kolv)=0
		tag_kolv=m.tag_kolv-1
	CASE INLIST(m.tag_nomer,12)	&& конец страницы
		***
	CASE INLIST(m.tag_nomer,13)	&& CASE
		***
	CASE INLIST(m.tag_nomer,14)	&& OTHERWISE
		***
	CASE INLIST(m.tag_nomer,15)	&& ENDCASE
		***
	OTHERWISE
		rep_errs='Неверно описана структура шаблона!'
		RETURN -1
	ENDCASE
	obj_type=m.tag_nomer
	rzd_type=IIF(m.tag_kolv=0,8,tag_mass(m.tag_kolv))
RETURN 1
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION ENCODE_SYMBOLS	&& замена русских букв на HEX-коды
LPARAMETERS rus_text
LOCAL i,kus_text,out_hex
	out_hex=''
	SET TEXTMERGE ON
	SET TEXTMERGE TO Memvar out_hex ADDITIVE NOSHOW
	FOR i=1 TO LEN(m.rus_text)
		kus_text=SUBSTR(m.rus_text, m.i, 1)
		\\<<Iif(ASC(m.kus_text)<127, m.kus_text, LOWER("\'"+RIGHT(TRANSFORM(ASC(m.kus_text),'@0'),2)))>>
	ENDFOR
	SET TEXTMERGE OFF
	SET TEXTMERGE TO
RETURN m.out_hex
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION NUM_RAZDEL	&& разделить разряды числа пробелами
PARAMETERS in_hislo	&& число
LOCAL i,len_hislo
	in_hislo=ALLTRIM(PADL(m.in_hislo,30))
	len_hislo=LEN(IIF("."$m.in_hislo,GETWORDNUM(m.in_hislo,1,"."),m.in_hislo))
	FOR i=m.len_hislo-2 TO 2 STEP -3
		in_hislo=STUFF(m.in_hislo,m.i,0," ")
	ENDFOR
RETURN ALLTRIM(m.in_hislo)
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION REP_DATAPROP	&& выводит дату прописью - {01.01.2000} в виде "01 января 2000 г."
PARAMETERS tmpdata
RETURN CHRTRAN(STR(DAY(m.tmpdata),2)," ","0")+" "+REP_GET_MES(MONTH(m.tmpdata),1)+" "+STR(YEAR(m.tmpdata),4)+" г."
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION REP_PERNAME	&& описание периода, заданного в виде строки '200501'
PARAMETERS period_now,period_cfg
* period_now - строка в виде "200901" (год+месяц) или "20091" (год+номер квартала или полугодия)
* period_cfg - доп настройка
*	Q - квартал
*	H - полугодие
*-ПРИМЕР ЗАПУСКА ----------------------------------------------------------------------------
* ? REP_PERNAME("200903")
*--------------------------------------------------------------------------------------------
	IF VARTYPE(m.period_cfg)#"C"
		period_cfg=''
	ENDIF
	IF INLIST(VARTYPE(m.period_now),"D","T")
		period_now=LEFT(DTOS(m.period_now),6)
	ENDIF
	LOCAL ret_pername
	IF EMPTY(m.period_now)
		period_now=LEFT(DTOS(DATE()),6)
	ELSE
		period_now=LEFT(m.period_now,6)
	ENDIF
	DO CASE
	CASE "H"$m.period_cfg
		ret_pername=IIF(LEN(m.period_now)=5,RIGHT(m.period_now,1),STR(CEILING(VAL(RIGHT(m.period_now,2))/6),1))+' полугодие '+LEFT(m.period_now,4)+" г."
	CASE "Q"$m.period_cfg
		ret_pername=IIF(LEN(m.period_now)=5,RIGHT(m.period_now,1),STR(CEILING(VAL(RIGHT(m.period_now,2))/3),1))+' квартал '+LEFT(m.period_now,4)+" г."
	CASE "P"$m.period_cfg	&& падеж - январь > января
		ret_pername=REP_GET_MES(VAL(RIGHT(m.period_now,2)),1)+' '+LEFT(m.period_now,4)+" г."
	OTHERWISE
		ret_pername=REP_GET_MES(VAL(RIGHT(m.period_now,2)))+' '+LEFT(m.period_now,4)+" г."
	ENDCASE
RETURN m.ret_pername
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION REP_GET_MES	&& возвращает наименование месяца в нужном падеже
PARAMETERS mes_nom,kak	&& ret_mes - номер месяца, kak =0/1, 1 - в виде января и т.д.
*-ПРИМЕР ЗАПУСКА ----------------------------------------------------------------------------
* ? REP_GET_MES(1)
*--------------------------------------------------------------------------------------------
	IF VARTYPE(m.kak)#'N'
		kak=0
	ENDIF
	LOCAL ret_mes
	ret_mes=''
	DIMENSION naim_mes(12)
	naim_mes(1)="Январь"
	naim_mes(2)="Февраль"
	naim_mes(3)="Март "
	naim_mes(4)="Апрель"
	naim_mes(5)="Май"
	naim_mes(6)="Июнь"
	naim_mes(7)="Июль"
	naim_mes(8)="Август "
	naim_mes(9)="Сентябрь"
	naim_mes(10)="Октябрь"
	naim_mes(11)="Ноябрь"
	naim_mes(12)="Декабрь"
	ret_mes=naim_mes(m.mes_nom)
	IF m.kak=1 
		IF INLIST(m.mes_nom,3,8)
			ret_mes=LEFT(m.ret_mes,LEN(m.ret_mes)-1)+"а"
		ELSE
			ret_mes=LEFT(m.ret_mes,LEN(m.ret_mes)-1)+"я"
		ENDIF
	ENDIF
RETURN m.ret_mes
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION REP_NUM_PROP	&& цифра прописью, при nDrobn=0 пишет рубли и копейки, >0 - целые и дробные
PARAMETER nSumma,nDrobn
	IF VARTYPE(m.nSumma)#"N" && Если не задан параметр
	    nSumma = 0
	ENDIF
	IF VARTYPE(m.nDrobn)#"N" && Если не задан параметр
	    nDrobn = 0
	ELSE
		nSumma=ROUND(m.nSumma,m.nDrobn)
	ENDIF
	nDrobn=IIF(m.nDrobn>3,3,m.nDrobn)
	PRIVATE cSumma  
	* k - копейки  
	IF m.nDrobn=0
		cSumma = TRANSFORM(M.nSumma,'9,9,,9,,,,,,9,9,,9,,,,,9,9,,9,,,,9,9,,9,,,.99')+'k'
		cSumma = IIF(SUBSTR(m.cSumma,LEN(m.cSumma)-3,1)=='.',m.cSumma,STUFF(m.cSumma,LEN(m.cSumma)-3,1,"."))	&& если SET POINT = ",", восстанавливаем точку
	ELSE
		cSumma = TRANSFORM(FLOOR(M.nSumma),'9,9,,9,,,,,,9,9,,9,,,,,9,9,,9,,,,9,9,,9,,,.')
		cSumma = IIF(RIGHT(m.cSumma,1)=='.',m.cSumma,LEFT(m.cSumma,LEN(m.cSumma)-1)+".")						&& если SET POINT = ",", восстанавливаем точку
		cSumma = m.cSumma + ALLTRIM(STR((M.nSumma-FLOOR(M.nSumma))*10^m.nDrobn,3))
	ENDIF
	cSumma=CHRTRAN(cSumma,CHR(160),",")		&& лечение глюка: в EXE файле меняет запятые на символ со значением 160

* t - тысячи; m - миллионы; M - миллиарды  
    cSumma = STRTRAN(M.cSumma, ',,,,,,', 'eM')  
    cSumma = STRTRAN(M.cSumma, ',,,,,',  'em')  
    cSumma = STRTRAN(M.cSumma, ',,,,',   'et')  

* e - единицы; d - десятки; c - сотни  
    cSumma = STRTRAN(M.cSumma, ',,,', 'e')  
    cSumma = STRTRAN(M.cSumma, ',,',  'd')  
    cSumma = STRTRAN(M.cSumma, ',',   'c')  

    cSumma = STRTRAN(M.cSumma, '0c0d0et', '')  
    cSumma = STRTRAN(M.cSumma, '0c0d0em', '')  
    cSumma = STRTRAN(M.cSumma, '0c0d0eM', '')  

    cSumma = STRTRAN(M.cSumma, '0c', '')  
    cSumma = STRTRAN(M.cSumma, '1c', 'сто ')  
    cSumma = STRTRAN(M.cSumma, '2c', 'двести ')  
    cSumma = STRTRAN(M.cSumma, '3c', 'триста ')  
    cSumma = STRTRAN(M.cSumma, '4c', 'четыреста ')  
    cSumma = STRTRAN(M.cSumma, '5c', 'пятьсот ')  
    cSumma = STRTRAN(M.cSumma, '6c', 'шестьсот ')  
    cSumma = STRTRAN(M.cSumma, '7c', 'семьсот ')  
    cSumma = STRTRAN(M.cSumma, '8c', 'восемьсот ')  
    cSumma = STRTRAN(M.cSumma, '9c', 'девятьсот ')  

    cSumma = STRTRAN(M.cSumma, '1d0e', 'десять ')  
    cSumma = STRTRAN(M.cSumma, '1d1e', 'одиннадцать ')  
    cSumma = STRTRAN(M.cSumma, '1d2e', 'двенадцать ')  
    cSumma = STRTRAN(M.cSumma, '1d3e', 'тринадцать ')  
    cSumma = STRTRAN(M.cSumma, '1d4e', 'четырнадцать ')  
    cSumma = STRTRAN(M.cSumma, '1d5e', 'пятнадцать ')  
    cSumma = STRTRAN(M.cSumma, '1d6e', 'шестнадцать ')  
    cSumma = STRTRAN(M.cSumma, '1d7e', 'семьнадцать ')  
    cSumma = STRTRAN(M.cSumma, '1d8e', 'восемнадцать ')  
    cSumma = STRTRAN(M.cSumma, '1d9e', 'девятнадцать ')  

    cSumma = STRTRAN(M.cSumma, '0d', '')  
    cSumma = STRTRAN(M.cSumma, '2d', 'двадцать ')  
    cSumma = STRTRAN(M.cSumma, '3d', 'тридцать ')  
    cSumma = STRTRAN(M.cSumma, '4d', 'сорок ')  
    cSumma = STRTRAN(M.cSumma, '5d', 'пятьдесят ')  
    cSumma = STRTRAN(M.cSumma, '6d', 'шестьдесят ')  
    cSumma = STRTRAN(M.cSumma, '7d', 'семьдесят ')  
    cSumma = STRTRAN(M.cSumma, '8d', 'восемьдесят ')  
    cSumma = STRTRAN(M.cSumma, '9d', 'девяносто ')  

    cSumma = STRTRAN(M.cSumma, '0e', '')  
    cSumma = STRTRAN(M.cSumma, '5e', 'пять ')  
    cSumma = STRTRAN(M.cSumma, '6e', 'шесть ')  
    cSumma = STRTRAN(M.cSumma, '7e', 'семь ')  
    cSumma = STRTRAN(M.cSumma, '8e', 'восемь ')  
    cSumma = STRTRAN(M.cSumma, '9e', 'девять ')  

    cSumma = STRTRAN(M.cSumma, '1e.', IIF(m.nDrobn=0,'один рубль ','одна целая '))
    cSumma = STRTRAN(M.cSumma, '2e.', IIF(m.nDrobn=0,'два рубля ','две целых '))
    cSumma = STRTRAN(M.cSumma, '3e.', IIF(m.nDrobn=0,'три рубля ','три целых '))
    cSumma = STRTRAN(M.cSumma, '4e.', IIF(m.nDrobn=0,'четыре рубля ','четыре целых '))
    cSumma = STRTRAN(M.cSumma, '1et', 'одна тысяча ')  
    cSumma = STRTRAN(M.cSumma, '2et', 'две тысячи ')  
    cSumma = STRTRAN(M.cSumma, '3et', 'три тысячи ')  
    cSumma = STRTRAN(M.cSumma, '4et', 'четыре тысячи ')  
    cSumma = STRTRAN(M.cSumma, '1em', 'один миллион ')  
    cSumma = STRTRAN(M.cSumma, '2em', 'два миллиона ')  
    cSumma = STRTRAN(M.cSumma, '3em', 'три миллиона ')  
    cSumma = STRTRAN(M.cSumma, '4em', 'четыре миллиона ')  
    cSumma = STRTRAN(M.cSumma, '1eM', 'один миллиард ')  
    cSumma = STRTRAN(M.cSumma, '2eM', 'два миллиарда ')  
    cSumma = STRTRAN(M.cSumma, '3eM', 'три миллиарда ')  
    cSumma = STRTRAN(M.cSumma, '4eM', 'четыре миллиарда ')  

	cSumma = STRTRAN(M.cSumma, '11k', '11 копеек')  
	cSumma = STRTRAN(M.cSumma, '12k', '12 копеек')  
	cSumma = STRTRAN(M.cSumma, '13k', '13 копеек')  
	cSumma = STRTRAN(M.cSumma, '14k', '14 копеек')  
	cSumma = STRTRAN(M.cSumma, '1k', '1 копейка')  
	cSumma = STRTRAN(M.cSumma, '2k', '2 копейки')  
	cSumma = STRTRAN(M.cSumma, '3k', '3 копейки')  
	cSumma = STRTRAN(M.cSumma, '4k', '4 копейки')  
	    
	cSumma = STRTRAN(M.cSumma, '.', IIF(m.nDrobn=0,'рублей ','целых '))  
	cSumma = STRTRAN(M.cSumma, 't', 'тысяч ')  
	cSumma = STRTRAN(M.cSumma, 'm', 'миллионов ')  
	cSumma = STRTRAN(M.cSumma, 'M', 'миллиардов ')  
	cSumma = STRTRAN(M.cSumma, 'k', ' копеек')

	IF m.nDrobn#0
		DO CASE
	   		CASE RIGHT(m.cSumma,1)='1' .and. RIGHT(m.cSumma,2)#'11'
				cSumma = m.cSumma+GETWORDNUM(' десят| сот| тысячн',m.nDrobn,'|')+'ая'
	   		CASE BETWEEN(RIGHT(m.cSumma,1),'2','4') .and. !BETWEEN(RIGHT(m.cSumma,2),'12','14')
				cSumma = m.cSumma+GETWORDNUM(' десят| сот| тысячн',m.nDrobn,'|')+'ые'
	   		OTHERWISE
				cSumma = m.cSumma+GETWORDNUM(' десят| сот| тысячн',m.nDrobn,'|')+'ых'
		ENDCASE
	ENDIF

	cSumma = Iif(M.nSumma < 1,'ноль '+allt(M.cSumma),M.cSumma)
	cSumma=allt(IIF(M.nSumma < 10**12, M.cSumma, ALLTRIM(STR(M.nSumma,20,2))))  
	cSumma=upper(left(m.cSumma,1))+lower(substr(m.cSumma,2))  
RETURN m.cSumma  
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION PrintAny	&& Печать WORD документов
PARAMETERS docfile,prnname,prcopies,prpages,rep_config
* docfile	- Файл для печати
* prnname	- Принтер (по умолчанию = DEFAULT)
* prcopies	- Копий (по умолчанию =1) 
* prpages	- Диапазон листов для печати | BOOK - печать книжкой | SIDE - печать поочередно нечетных и четных страниц
* rep_config- конфигурация
*	[HIDE]  - не показывать сообщения пользователю
*--------------------------------------------------------------------------------------------
	IF VARTYPE(m.prnname)#"C"
		prnname=''
	ENDIF
	IF VARTYPE(m.prcopies)#"N" OR m.prcopies<=0
		prcopies=1
	ENDIF
	IF VARTYPE(m.prpages)#"C" OR (!EMPTY(CHRTRAN(m.prpages,"1234567890,- ","")) AND !INLIST(ALLTRIM(UPPER(m.prpages)),"BOOK","SIDE"))
		prpages=''
	ENDIF
	IF VARTYPE(m.rep_config)#"C"
		rep_config=''
	ENDIF
	IF !FILE(m.docfile)
		RETURN 0
	ENDIF
	docfile=FULLPATH(m.docfile)
	LOCAL loWord, loBook, kollist, errprint, openword
	errprint=0
	openword=0
	DECLARE Sleep IN kernel32 INTEGER dwMilliseconds
	TRY
		loWord=CREATEOBJECT('Word.Application')
		loWord.Visible=.f.
		openword=1					&& добрались до этой строки - значит будем закрывать WORD при завершении
		loBook = m.loWord.Documents.open(m.docfile)
		IF !EMPTY(m.prnname) AND APRINTERS(gaPrinters)>0 AND ASCAN(gaPrinters,ALLTRIM(prnname))#0	&& проверка наличия целевого принтера
			loWord.ActivePrinter=m.prnname
		ENDIF
		WAIT WINDOW IIF("[HIDE]"$UPPER(m.rep_config),"","Идет печать...") NOWAIT NOCLEAR
		DO CASE
		CASE ALLTRIM(UPPER(m.prpages))=="BOOK"										&& печать книжкой
			kollist=LoWord.ActiveDocument.ActiveWindow.Panes(1).Pages.Count			&& кол-во листов в документе
			IF m.kollist%2=1														&& нечетное кол-во листов
				loWord.ActiveDocument.Range.Select
				loWord.Selection.EndKey(6)
				loWord.Selection.TypeParagraph										&& добавляем новый параграф с очищенным форматированием
				loWord.Selection.ClearFormatting
				kollist=LoWord.ActiveDocument.ActiveWindow.Panes(1).Pages.Count		&& кол-во листов в документе
				DO WHILE m.kollist%4#0
					loWord.Selection.InsertBreak(2)									&& добавляем лист, чтобы было кол-во/4=0
					kollist=LoWord.ActiveDocument.ActiveWindow.Panes(1).Pages.Count		&& кол-во листов в документе
				ENDDO
			ENDIF
			prpages=''
			FOR i=1 TO CEILING(m.kollist/2) STEP 2
				prpages=IIF(EMPTY(m.prpages),"",m.prpages+",")+ALLTRIM(STR(m.kollist+m.kollist%2-(m.i-1)))+","+ALLTRIM(STR(m.i))
			ENDFOR
			LoWord.ActiveDocument.PrintOut(,,4,,,,,m.prcopies,m.prpages,,,.T.,,,2,1)	&& печать
			DO WHILE !EMPTY(LoWord.Application.BackgroundPrintingStatus)	&& ждем, пока напечатает
				=Sleep(1000)
			ENDDO
			WAIT CLEAR
			IF MESSAGEBOX("Дождитесь, пока принтер не закончит печатать и положите пачку отпечатанных листов"+CHR(13)+"так, чтобы он начал печатать на чистой стороне листа."+CHR(13)+CHR(13)+"Продолжить печать?",36,"Внимание!")=6
				WAIT WINDOW IIF("[HIDE]"$UPPER(m.rep_config),"","Идет печать...") NOWAIT NOCLEAR
				prpages=''
				FOR i=2 TO CEILING(m.kollist/2) STEP 2
					prpages=IIF(EMPTY(m.prpages),"",m.prpages+",")+ALLTRIM(STR(m.i))+","+ALLTRIM(STR(m.kollist+m.kollist%2-(m.i-1)))
				ENDFOR
				LoWord.ActiveDocument.PrintOut(,,4,,,,,m.prcopies,m.prpages,,,.T.,,,2,1)	&& печать
				DO WHILE !EMPTY(LoWord.Application.BackgroundPrintingStatus)	&& ждем, пока напечатает
					=Sleep(1000)
				ENDDO
			ENDIF
		CASE ALLTRIM(UPPER(m.prpages))=="SIDE"										&& печать книжкой
			kollist=LoWord.ActiveDocument.ActiveWindow.Panes(1).Pages.Count			&& кол-во листов в документе
			prpages=''
			FOR i=1 TO m.kollist STEP 2
				prpages=m.prpages+IIF(EMPTY(m.prpages),"",",")+ALLTRIM(STR(m.i))
			ENDFOR
			LoWord.ActiveDocument.PrintOut(,,4,,,,,m.prcopies,m.prpages,,,.T.)	&& печать указанных листов
			DO WHILE !EMPTY(LoWord.Application.BackgroundPrintingStatus)	&& ждем, пока напечатает
				=Sleep(1000)
			ENDDO
			WAIT CLEAR
			IF MESSAGEBOX("Дождитесь, пока принтер не закончит печатать и положите пачку отпечатанных листов"+CHR(13)+"так, чтобы он начал печатать на чистой стороне листа."+CHR(13)+CHR(13)+"Продолжить печать?",36,"Внимание!")=6
				WAIT WINDOW IIF("[HIDE]"$UPPER(m.rep_config),"","Идет печать...") NOWAIT NOCLEAR
				prpages=''
				FOR i=2 TO m.kollist STEP 2
					prpages=m.prpages+IIF(EMPTY(m.prpages),"",",")+ALLTRIM(STR(m.i))
				ENDFOR
				LoWord.ActiveDocument.PrintOut(,,4,,,,,m.prcopies,m.prpages,,,.T.)	&& печать указанных листов
			ENDIF
		CASE !EMPTY(m.prpages)
			LoWord.ActiveDocument.PrintOut(,,4,,,,,m.prcopies,m.prpages,,,.T.)	&& печать указанных листов
		OTHERWISE
			LoWord.ActiveDocument.PrintOut(,,,,,,,m.prcopies,,,,.T.)			&& печать всего документа
		ENDCASE
		DO WHILE !EMPTY(LoWord.Application.BackgroundPrintingStatus)			&& ждем, пока напечатает
			=Sleep(1000)
		ENDDO
		LoWord.Quit(0)
		LoWord=.NULL.
	CATCH TO goto_error
		errprint=1
		IF m.openword=1
			LoWord.Quit(0)
			LoWord=.NULL.
		ENDIF
	ENDTRY
	CLEAR DLLS "Sleep"
	RELEASE m.LoWord
RETURN IIF(m.errprint=1,-1,1)
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION SPLIT_REPORT	&& Разделение отчета на несколько файлов
PARAMETERS f_shabl, f_othet, rep_config, ali_reps
*	f_othet		- файл результата, должен иметь символ "%" для вставки номера файла, например "REP%.RTF"
*	all_rows	- общее количество записей в основной таблице
*	rep_config	- должен содержать настройки для отчета и дополнительно параметр [SPLIT=*], где "*" - MAX количество записей в томе.
*				- может содержать параметр [STOMS=1,2,5-8] для формирования только указанных томов.
* 	ali_reps	- Список алиасов, которые составляют разделы отчета через "|"
*--------------------------------------------------------------------------------------------
* Описание применения:
*--------------------------------------------------------------------------------------------
* Данная функция может быть применена: 
*		1 - для формирования многотомных (разбитых на N файлов) отчетов.
*		2 - для формирования результирующего файла, размером более 2 Гбт - для этого сформированные тома сшиваются в один с помощью 
*		команды COPY Файл1+Файл2+ФайлN Файлрезультат. При этом не забывать добавлять условия: 
*			для шапки отчета: 	[REP:CASE=m._rep_tekl=1]
*			для хвоста отчета:	[REP:CASE=m._rep_tekl=m._rep_maxl]
*--------------------------------------------------------------------------------------------
* Ограничения:
*--------------------------------------------------------------------------------------------
* 1. Основные таблицы в отчете должна быть объявленны как [REP:ALI=Ваш алиас|USL=_rep_uslv(№ таблицы)], 
*    где _rep_uslv(№ таблицы) - условия для каждой таблицы, формируемые в этой функции
* 2. Основные таблицы не должны содержать дополнительных фильтров
*--------------------------------------------------------------------------------------------
	LOCAL i,j,tmp_name,ret_error,tom_rows,f_conftxt,tom_count,tek_rows,tek_tabl,ali_rows,now_rows,tek_gran,tom_only
	tom_rows=0
	tom_only=''
	FOR i=1 TO GETWORDCOUNT(m.rep_config,"]")
		f_conftxt=ALLTRIM(GETWORDNUM(m.rep_config,m.i,"]"))
		DO CASE
		CASE ALLTRIM(UPPER(LEFT(m.f_conftxt,7)))=="[SPLIT="
			tom_rows=VAL(ALLTRIM(SUBSTR(m.f_conftxt,AT("=",m.f_conftxt)+1)))
		CASE ALLTRIM(UPPER(LEFT(m.f_conftxt,7)))=="[STOMS="
			tom_only=ALLTRIM(SUBSTR(m.f_conftxt,AT("=",m.f_conftxt)+1))
		ENDCASE
	ENDFOR
	IF m.tom_rows=0		&& не задан параметр разделения
		RETURN -1
	ENDIF
*--------------------------------------------------------------------------------------------
	DIMENSION _rep_alia(GETWORDCOUNT(m.ali_reps,"|"),2)
	all_rows=0
	FOR i=1 TO GETWORDCOUNT(m.ali_reps,"|")
		_rep_alia(m.i,1)=ALLTRIM(GETWORDNUM(m.ali_reps,m.i,"|"))
		IF !USED(_rep_alia(m.i,1))
			RETURN -2
		ENDIF
		SELECT (_rep_alia(m.i,1))
		COUNT TO _rep_alia(m.i,2)
		all_rows=m.all_rows+_rep_alia(m.i,2)
	ENDFOR
*--------------------------------------------------------------------------------------------
	tom_count=CEILING(m.all_rows/m.tom_rows)	&& количество томов
	DIMENSION _rep_recn(m.tom_count,GETWORDCOUNT(m.ali_reps,"|"))	&& матрица диапазонов строк для всех таблиц по томам
	tek_rows=0									&& общее количество обработанных записей
	tek_tabl=1									&& общее количество обработанных таблиц
	ali_rows=0									&& количество обработанных записей текущей таблицы в предыдущем томе
	now_rows=0									&& количество обработанных записей за текущую итерацию
*--------------------------------------------------------------------------------------------
	FOR i=1 TO m.tom_count											&& для каждого тома
		FOR j=1 TO GETWORDCOUNT(m.ali_reps,"|")						&& по каждой таблице формируем диапазоны записей
			tek_gran=m.i*m.tom_rows-m.tek_rows						&& записей до разделения в текущем томе
			IF m.j=m.tek_tabl										&& № таблицы = текущей
				IF _rep_alia(m.tek_tabl,2)-m.ali_rows<=m.tek_gran	&& кол-во необработанных записей в таблице меньше либо равно кол-ву записей до разделения тома
					now_rows=_rep_alia(m.j,2)-m.ali_rows
					_rep_recn(m.i,m.j)=ALLTRIM(STR(m.ali_rows+1))+","+ALLTRIM(STR(_rep_alia(m.j,2)))
					tek_rows=m.tek_rows+m.now_rows
					ali_rows=0										&& обнуляем кол-во 
					tek_tabl=m.tek_tabl+1							&& переключаем на следующую таблицу
				ELSE
					now_rows=m.tek_gran
					_rep_recn(m.i,m.j)=ALLTRIM(STR(m.ali_rows+1))+","+ALLTRIM(STR(m.ali_rows+m.now_rows))
					tek_rows=m.tek_rows+m.now_rows
					ali_rows=m.ali_rows+m.now_rows
				ENDIF
			ENDIF
		ENDFOR
	ENDFOR
*--------------------------------------------------------------------------------------------
	DIMENSION _rep_uslv(GETWORDCOUNT(m.ali_reps,"|"))				&& массив условий таблиц для текущего тома
	FOR i=1 TO m.tom_count											&& формируем тома
		IF !EMPTY(m.tom_only) AND GET_INLIST(m.tom_only,m.i)#1		&& заданы тома для формирования и текущий том формировать не нужно
			LOOP
		ENDIF
		FOR j=1 TO GETWORDCOUNT(m.ali_reps,"|")						&& по каждой таблице формируем условие в этом томе
			_rep_uslv(j)="BETWEEN(RECNO(),"+IIF(EMPTY(_rep_recn(m.i,m.j)),"0,0",_rep_recn(m.i,m.j))+")"
		ENDFOR
		tmp_name=STRTRAN(m.f_othet,"%",ALLTRIM(STR(m.i)))
		ret_error=RTF_REPORT(m.f_shabl,m.tmp_name,m.rep_config)
		IF !EMPTY(m.ret_error)
			=MESSAGEBOX(m.ret_error,16,"Ошибка")
			EXIT
		ENDIF
	ENDFOR
RETURN m.ret_error
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION GET_INLIST	&& проверка, относится ли заданное число к диапазону, заданному в виде "1,2,5-8"
PARAMETERS list_str,list_now
* list_str - диапазон
* list_now - число
*--------------------------------------------------------------------------------------------
	IF VARTYPE(m.list_str)#"C" OR VARTYPE(m.list_now)#"N"
		RETURN -1
	ENDIF
	LOCAL i,list_tmp,list_min,list_max
	list_min=0
	list_max=0
	FOR i=1 TO GETWORDCOUNT(m.list_str,",")
		list_tmp=GETWORDNUM(m.list_str,m.i,",")
		IF "-"$m.list_tmp
			list_min=VAL(GETWORDNUM(m.list_tmp,1,"-"))
			list_max=VAL(GETWORDNUM(m.list_tmp,2,"-"))
		ELSE
			list_min=VAL(m.list_tmp)
			list_max=m.list_min
		ENDIF
		IF BETWEEN(m.list_now,m.list_min,m.list_max)
			RETURN 1
		ENDIF
	ENDFOR
RETURN 0
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION XLS_REPORT	&& выгрузка в EXCEL с использованием XML EXCEL шаблона
PARAMETERS f_shabl, f_othet, rep_config, rez_format
*--------------------------------------------------------------------------------------------
* @ TAS - 2019 г. Все параметры необязательны!
*--------------------------------------------------------------------------------------------
* 1 - f_shabl - файл шаблона
* 2 - f_othet - файл результата
* 3 - rep_config (не обязательно) - Конфигурация запуска - может содержать любой набор из нижеперечисленных вариантов:
*	[SHOW]  - показать XLS отчет
*	доп параметры см. в функции RTF_REPORT
* 4 - rez_format (не обязательно) - формат результата, для функции SaveAs() MS EXCEL (см. xlFileFormat https://docs.microsoft.com/en-us/office/vba/api/excel.xlfileformat).
*--------------------------------------------------------------------------------------------
* Шаблон EXCEL должен содержать те-же теги, что описаны для WORD, заданные в первой колонке.
* Первая колонка и строки со служебными тегами из готового документа будут удалены!!!
*--------------------------------------------------------------------------------------------
* ? XLS_REPORT("test2.xls","ready.xlsx","[SHOW]",51)	&& 
*--------------------------------------------------------------------------------------------
LOCAL i,j, t_kol, ret_txt, row_txt, row_del, tmp_txt, kol_spt, kol_add
LOCAL all_txt, tek_str, tmp_shabl, tmp_othet, row_skip
	rep_errs=''	 && переменная для ошибки
	rep_config=IIF(VARTYPE(m.rep_config)#"C","",m.rep_config)
	rez_format=IIF(VARTYPE(m.rez_format)#"N",ICASE(UPPER(JUSTEXT(m.f_othet))="XLS",56,UPPER(JUSTEXT(m.f_othet))="XLSX",51,0),m.rez_format) && если расширение результата - XLS*, то будем преобразовывать результат в формат EXCEL файла автоматом
	IF EMPTY(JUSTPATH(m.f_othet))
		m.f_othet=SYS(5)+CURDIR()+m.f_othet	&& дополняем полным путем, иначе EXCEL не поймет
	ENDIF
	IF !FILE(m.f_shabl)
		rep_errs='Не найден файл шаблона!'
	ELSE
		all_txt=STRCONV(FILETOSTR(m.f_shabl),11)	
		ret_txt=''	&& результат
		row_del=0	&& признак удаления строки
		kol_spt=0	&& кол-во строк, закрепленных в заголовке
		kol_add=1	&& Признак для подсчета kol_spt
		kol_col=0	&& кол-во колонок
*--------------------------------------------------------------------------------------------
* Преобразование XML EXCEL файла в шаблон для RTF_REPORT на основе данных первой колонки
*--------------------------------------------------------------------------------------------
		t_kol=ALINES(aMyArray, m.all_txt)
		FOR i=1 TO m.t_kol
			tek_str=aMyArray(m.i)
			DO WHILE OCCURS("<",m.tek_str)#OCCURS(">",m.tek_str) AND m.i<=m.t_kol	&& собираем строки
				i=m.i+1
				tek_str=m.tek_str+' '+ALLTRIM(aMyArray(m.i))
			ENDDO
			DO CASE
			CASE UPPER(LEFT(ALLTRIM(m.tek_str),4))=="<ROW"	&& начало строки
				row_txt=GETWORDNUM(m.tek_str,1," ")
				FOR j=2 TO GETWORDCOUNT(m.tek_str," ")
					IF !"INDEX="$UPPER(ALLTRIM(GETWORDNUM(m.tek_str,m.j," ")))	&& жестко заданные индексы убираем нафиг
						row_txt=m.row_txt+IIF(EMPTY(m.row_txt),'',' ')+ALLTRIM(GETWORDNUM(m.tek_str,m.j," "))
					ENDIF
				ENDFOR 
			CASE UPPER(LEFT(ALLTRIM(m.tek_str),5))=="</ROW"	&& Конец строки
				ret_txt=m.ret_txt+CHR(13)+m.row_txt
				IF row_del=0
					ret_txt=m.ret_txt+CHR(13)+m.tek_str
					kol_spt=m.kol_spt+m.kol_add				&& кол-во строк, закрепленных в заголовке
				ENDIF
				row_del=0
				LOOP
			CASE UPPER(LEFT(ALLTRIM(m.tek_str),5))=="<CELL"
				DO CASE
				CASE m.row_del=1		&& удаляем строку
					LOOP
				CASE "[REP:NOTE]"$m.tek_str	&& Строки с комментариями удаляем полностью
					row_del=1
					row_txt=''
				CASE "[REP:"$m.tek_str	&& служебные строки
					row_del=1
					row_txt=SUBSTR(m.tek_str,AT("[REP:",m.tek_str))
					row_txt=GETWORDNUM(m.row_txt,1,"]")+"]"
					IF "[REP:DETAIL]"$m.row_txt	&& достигли DETAIL - заголовок закончился
						kol_add=0
					ENDIF
					row_txt=STRTRAN(m.row_txt,"&lt;","<")	&& в служебных строках восстанавливаем экранированные символы
					row_txt=STRTRAN(m.row_txt,"&gt;",">")
				CASE "[REPVAR"$m.tek_str	&& служебные переменные
					row_del=1
					row_txt=SUBSTR(m.tek_str,AT("[REPVAR",m.tek_str))
					row_txt=GETWORDNUM(m.row_txt,1,"]")+"]"
					row_txt=STRTRAN(m.row_txt,"&lt;","<")	&& в служебных строках восстанавливаем экранированные символы
					row_txt=STRTRAN(m.row_txt,"&gt;",">")
				OTHERWISE
					DO WHILE !"</Cell>"$m.tek_str
						i=m.i+1
						tek_str=m.tek_str+" "+ALLTRIM(aMyArray(m.i))
					ENDDO
					row_txt=m.row_txt+IIF(EMPTY(m.row_txt),'',CHR(13))+m.tek_str
				ENDCASE
			CASE UPPER(LEFT(ALLTRIM(m.tek_str),6))=="<TABLE"
				IF "ss:ExpandedColumnCount="$m.tek_str
					FOR j=1 TO GETWORDCOUNT(m.tek_str," ")
						IF "ss:ExpandedColumnCount="$GETWORDNUM(m.tek_str,m.j," ")
							kol_col=INT(VAL(CHRTRAN(SUBSTR(GETWORDNUM(m.tek_str,m.j," "),24),'"','')))-1	 && кол-во колонок
							EXIT 
						ENDIF
					ENDFOR
				ENDIF
				ret_txt=m.ret_txt+CHR(13)+LEFT(m.tek_str,AT("ss:ExpandedRowCount",m.tek_str)-1)
				tmp_txt=SUBSTR(m.tek_str,AT("ss:ExpandedRowCount",m.tek_str)) && убираем кол-во строк
				tmp_txt=ALLTRIM(SUBSTR(m.tmp_txt,AT('"',m.tmp_txt,2)+1))
				ret_txt=m.ret_txt+m.tmp_txt
			CASE UPPER(LEFT(ALLTRIM(m.tek_str),7))=="<PANES>" OR UPPER(LEFT(ALLTRIM(m.tek_str),19))=="<DOCUMENTPROPERTIES" OR UPPER(LEFT(ALLTRIM(m.tek_str),11))=="<AUTOFILTER" &&OR UPPER(LEFT(ALLTRIM(m.tek_str),7))=="<NAMES>"
				row_del=1											&& теперь будем убирать все строки
			CASE UPPER(LEFT(ALLTRIM(m.tek_str),8))=="</PANES>" OR UPPER(LEFT(ALLTRIM(m.tek_str),20))=="</DOCUMENTPROPERTIES" OR UPPER(LEFT(ALLTRIM(m.tek_str),12))=="</AUTOFILTER" &&OR UPPER(LEFT(ALLTRIM(m.tek_str),8))=="</NAMES>"
				row_del=0											&& теперь НЕ будем убирать все строки
			CASE UPPER(LEFT(ALLTRIM(m.tek_str),11))=="<NAMEDRANGE"	
				IF "Print_Area"$m.tek_str 							&& только некоторые пропускаем
					ret_txt=m.ret_txt+IIF(EMPTY(m.ret_txt),'',CHR(13))+m.tek_str
				ENDIF
			OTHERWISE
				stoplist="<SplitHorizontal>|<TopRowBottomPane>|<ActivePane>|<TopRowVisible>|<LeftColumnVisible>" && уберем эти строки
				row_skip=0
				FOR j=1 TO GETWORDCOUNT(m.stoplist,"|")
					stopword=ALLTRIM(UPPER(GETWORDNUM(m.stoplist,m.j,"|")))
					IF UPPER(LEFT(ALLTRIM(m.tek_str),LEN(m.stopword)))==m.stopword
						row_skip=1
					ENDIF
				ENDFOR 
				IF m.row_del=0 AND m.row_skip=0	&& если не удаляем все строки и не пропускаем
					ret_txt=m.ret_txt+IIF(EMPTY(m.ret_txt),'',CHR(13))+m.tek_str
				ENDIF
			ENDCASE
		ENDFOR
	ENDIF
*--------------------------------------------------------------------------------------------
* Формирование временного файла с данными в формате XML EXCEL 
*--------------------------------------------------------------------------------------------
	tmp_shabl=SYS(2023)+'\'+SYS(3)+'.xml'
	tmp_othet=SYS(2023)+'\'+SYS(3)+'.xml'
	IF EMPTY(m.rep_errs) AND STRTOFILE(m.ret_txt,m.tmp_shabl)<=0	&& сохранение готового шаблона
		rep_errs='Шаблон не содержит данных!'
	ELSE
*		=STRTOFILE(m.ret_txt,'c:\tascold\1.xml')				&& для тестирования
		rep_errs=RTF_REPORT(m.tmp_shabl, m.tmp_othet, STRTRAN(m.rep_config,"[SHOW]","")+"[ENCODE=9][EXCEL]")	&& формирование файла с данными
*		=STRTOFILE(FILETOSTR(m.tmp_othet),'c:\tascold\2.xml')	&& для тестирования
	ENDIF
*--------------------------------------------------------------------------------------------
* Сохранение как документа EXCEL и финальные операции
*--------------------------------------------------------------------------------------------
	IF EMPTY(m.rep_errs)
		IF m.rez_format#0
			oExcel= CREATEOBJECT("Excel.Application")
			IF TYPE("oExcel")#"O"
				rep_errs='Не установлен Excel! Отчет не может быть сформирован!'
			ELSE
				oExcel.DisplayAlerts = .F.
				TRY
					oExcel.Workbooks.OpenXML(m.tmp_othet,,2)
					oExcel.ActiveWorkbook.SaveAs(m.f_othet,m.rez_format)	&& попытка сохранения в заданном формате
				CATCH TO goto_error
					IF VARTYPE(m.proglang)="N" AND m.proglang=1	&& ENG
						rep_error="Error saving report: "+goto_error.message
					ELSE
						rep_error="Ошибка сохранения отчета: "+goto_error.message
					ENDIF
				ENDTRY
				oExcel.Quit
			ENDIF
		ELSE
			TRY
				=STRTOFILE(FILETOSTR(m.tmp_othet),m.f_othet)	&& сохранение временного отчета как результат
			CATCH TO goto_error
				IF VARTYPE(m.proglang)="N" AND m.proglang=1	&& ENG
					rep_error="Error saving report: "+goto_error.message
				ELSE
					rep_error="Ошибка сохранения отчета: "+goto_error.message
				ENDIF
			ENDTRY
		ENDIF
		IF EMPTY(m.rep_errs) AND "[SHOW]"$UPPER(m.rep_config)	&& Показать отчет
			WSHShell=CreateObject("WScript.Shell",0,.F.)
			WSHShell.Run('"'+m.f_othet+'"')
		ENDIF
	ENDIF
	IF FILE(m.tmp_shabl)
		DELETE FILE (m.tmp_shabl)
	ENDIF
	IF FILE(m.tmp_othet)
		DELETE FILE (m.tmp_othet)
	ENDIF
RETURN m.rep_errs	&& пустая, если все ОК!
*############################################################################################
*############################################################################################
*############################################################################################
FUNCTION DBF_TOEXCEL	&& продвинутая выгрузка данных курсора в EXCEL
PARAMETERS rep_alias,rep_xname,rep_config,rep_sourse,rep_filter,rep_cols
*--------------------------------------------------------------------------------------------
* @ TAS - 2019 г. Все параметры необязательны!
*--------------------------------------------------------------------------------------------
* 1. rep_alias		- Alias источника данных, если не задан, то берется текущий.
* 2. rep_xname		- наименование файла, если не задан, то результат будет открыт в EXCEL.
* 3. rep_config		- конфиг:
*		[SHOW]  	- показать XLS отчет в EXCEL.
*		[EXCEL]		- вернуть объект для дополнительных действий.
*		[CTITL]		- выровнять заголовки колонок по центру и по середине высоты.
* 4. rep_sourse		- список полей для SELECT и сортировки в виде "fields1,fields2,fields3 ORDER= fields1,fields10"
* 					  можно указать * для включения в результат всех полей. Eсли не задан, то = "*".
*					  Фрагмент "ORDER=" является необязательным и может включать поля, отсутствующие в SELECT. 
* 5. rep_filter		- фильтр в виде условия для SQL запроса "field1=1 AND field2='ДА'" . Eсли не задан, то = "1=1".
* 6. rep_cols		- Доп настройки колонок через резделитель "|" в виде:.
*		"TC:1=текст1|TC:5=текст2" 	- для изменения наименования указанных колонок
*		"WT:1=50|WT:5=20" 			- для изменения ширины указанных колонок
*		"WR:1|WR:5" 				- для включения WordWrap указанных колонок
*--------------------------------------------------------------------------------------------
* Примеры использования:
*--------------------------------------------------------------------------------------------
* ? DBF_TOEXCEL('xsddata','111.xls',"[SHOW][CTITL]")
* ? DBF_TOEXCEL('xsddata',"","[EXCEL][CTITL]")
*--------------------------------------------------------------------------------------------
* Возврат:
*	- пустая строка, если все ОК.
*	- текст ошибки при ошибки
*	- объект, если задан параметр [EXCEL] и не было ошибки. В объекте есть кол-во строк и колонок, а также сам oExcel.
*--------------------------------------------------------------------------------------------
	LOCAL oExcel, rep_xtemp, rep_select, rep_order, tmp_alias, rep_error, tek_alias, col_data, col_znah, tmp_field(1)
	LOCAL kol_rows, kol_cols, _my_rep, add_tmprow, col_maxlit
*--------------------------------------------------------------------------------------------
*	Проверки и первичная обработка входящих параметров
*--------------------------------------------------------------------------------------------
	add_tmprow=0		&& Если придутся добавлять строку, чтобы EXCEL добавил наименования колонок
	rep_error=''		&& Для ошибки
	tek_alias=ALIAS()	&& Сюда вернем алиас при выходе
	rep_alias=IIF(VARTYPE(m.rep_alias)#"C" OR EMPTY(m.rep_alias),ALIAS(),ALLTRIM(m.rep_alias))
	rep_xname=IIF(VARTYPE(m.rep_xname)#"C","",m.rep_xname)
	rep_sourse=IIF(VARTYPE(m.rep_sourse)#"C" OR EMPTY(m.rep_sourse),"*",m.rep_sourse)
	rep_filter=IIF(VARTYPE(m.rep_filter)#"C" OR EMPTY(m.rep_filter),"1=1",m.rep_filter)
	rep_config=IIF(VARTYPE(m.rep_config)#"C","",m.rep_config)
	rep_cols=IIF(VARTYPE(m.rep_cols)#"C","",m.rep_cols)
	IF EMPTY(m.rep_alias) OR !USED(m.rep_alias)
		IF VARTYPE(m.proglang)="N" AND m.proglang=1	&& ENG
			RETURN 'No data source ALIAS specified or missing!'
		ELSE
			RETURN 'Не задан или отсутствует ALIAS источника данных!'
		ENDIF
	ENDIF
	IF !EMPTY(m.rep_xname) AND EMPTY(JUSTPATH(m.rep_xname))
		m.rep_xname=SYS(5)+CURDIR()+m.rep_xname	&& дополняем полным путем
	ENDIF
	rep_xtemp=SYS(2023)+'\'+SYS(3)+'.xml'
	IF EMPTY(m.rep_filter)
		m.rep_filter="1=1"
	ENDIF
	IF "ORDER="$UPPER(m.rep_sourse)
		rep_order="ORDER BY "+ALLTRIM(SUBSTR(m.rep_sourse,AT("ORDER=",UPPER(m.rep_sourse))+6))
		rep_sourse=ALLTRIM(LEFT(m.rep_sourse,AT("ORDER=",UPPER(m.rep_sourse))-1))
	ELSE
		rep_order=''
	ENDIF
*--------------------------------------------------------------------------------------------
*	Формирование курсора для отчета, при необходимости
*--------------------------------------------------------------------------------------------
	SELECT (m.rep_alias)
	COUNT TO kol_rows
	IF m.rep_sourse=="*" AND EMPTY(m.rep_order) AND m.rep_filter=="1=1" AND m.kol_rows>1
		tmp_alias=m.rep_alias
	ELSE
		tmp_alias="_xlsreport"
		TEXT TO sqlzapr NOSHOW TEXTMERGE PRETEXT 15
			SELECT <<m.rep_sourse>>
			FROM <<m.rep_alias>>
			WHERE <<m.rep_filter>>
			INTO CURSOR <<m.tmp_alias>> READWRITE <<m.rep_order>>
		ENDTEXT
		TRY
			=EXECSCRIPT(m.sqlzapr)
		CATCH TO goto_error
			IF VARTYPE(m.proglang)="N" AND m.proglang=1	&& ENG
				rep_error="Error performing request "+goto_error.message
			ELSE
				rep_error="Ошибка выполнения запроса "+goto_error.message
			ENDIF 
		ENDTRY
	ENDIF
*--------------------------------------------------------------------------------------------
*	Формирование файла отчета
*--------------------------------------------------------------------------------------------
	IF EMPTY(m.rep_error)
		TRY
			oExcel= CREATEOBJECT("Excel.Application")
		CATCH TO goto_error

		ENDTRY
		IF VARTYPE(m.oExcel)#"O"
			IF VARTYPE(m.proglang)="N" AND m.proglang=1	&& ENG
				rep_error="Microsoft Excel is not installed!"
			ELSE
				rep_error="Не установлен Microsoft Excel!"
			ENDIF
		ENDIF
	ENDIF
	IF EMPTY(m.rep_error)
		SELECT (m.tmp_alias)
		kol_cols=AFIELDS(tmp_field,m.tmp_alias)
		col_maxlit=IIF(m.kol_cols>26,CHR(64+INT(m.kol_cols/26)),"")+CHR(64+IIF(m.kol_cols%26=0,26,m.kol_cols%26))
		COUNT TO kol_rows
		DO CASE
		CASE m.kol_rows=0
			IF VARTYPE(m.proglang)="N" AND m.proglang=1	&& ENG
				rep_error="There is no data to report!"
			ELSE
				rep_error="Нет данных для формирования отчета!"
			ENDIF
		CASE m.kol_rows=1	&& одна строка - нужно отработать особое поведение EXCEL - добавить и удалить доп строку, чтобы EXCEL добавил заголовки.
			APPEND BLANK
			add_tmprow=1
		ENDCASE
	ENDIF
	IF EMPTY(m.rep_error)
		kol_rows=m.kol_rows+1							&& прибавляем заголовок
		IF CURSORTOXML(m.tmp_alias, m.rep_xtemp,1,512+16,0)>0
			oExcel.DisplayAlerts = .f.
			oExcel.Workbooks.OpenXML(m.rep_xtemp,,2)
			DELETE FILE (m.rep_xtemp)
*--------------------------------------------------------------------------------------------
*	Общее форматирование всего отчета
*--------------------------------------------------------------------------------------------
			all_cells="A1:"+m.col_maxlit+ALLTRIM(STR(m.kol_rows))
			oExcel.Range(m.all_cells).Cells.Borders.Weight=2
			oExcel.Range(m.all_cells).Cells.Borders.LineStyle=1
			oExcel.Range(m.all_cells).Cells.VerticalAlignment = 1
			IF add_tmprow=1								&& удаляем строку, которую добавили
				oExcel.Rows(m.kol_rows+1).Delete
			ENDIF
*--------------------------------------------------------------------------------------------
*	Формирование заголовков
*--------------------------------------------------------------------------------------------
			IF "[CTITL]"$UPPER(m.rep_config)			&& Выровнять заголовки колонок по центру и по середине высоты
				all_cells="A1:"+m.col_maxlit+"1"
				oExcel.Range(m.all_cells).Cells.WrapText = .T.
				oExcel.Range(m.all_cells).Cells.HorizontalAlignment = 3
				oExcel.Range(m.all_cells).Cells.VerticalAlignment = 2
			ENDIF
*--------------------------------------------------------------------------------------------
*	Наименования, заданные пользователем
*--------------------------------------------------------------------------------------------
			IF !EMPTY(m.rep_cols)						&& заданы заголовки или другие настройки колонок
				FOR i=1 TO GETWORDCOUNT(m.rep_cols,"|")
					col_data=GETWORDNUM(m.rep_cols,m.i,"|")
					kol_cols=m.i
					IF UPPER(LEFT(m.col_data,3))=="TC:" OR UPPER(LEFT(m.col_data,3))=="WT:"  OR UPPER(LEFT(m.col_data,3))=="WR:"	&& указан номер колонки
						kol_cols=GETWORDNUM(m.col_data,1,"=")
						col_znah=ALLTRIM(SUBSTR(m.col_data,AT("=",m.col_data)+1))
						kol_cols=VAL(GETWORDNUM(m.kol_cols,2,":"))
					ENDIF
					IF !EMPTY(m.kol_cols)
						DO CASE
						CASE UPPER(LEFT(m.col_data,3))=="TC:"
							oExcel.Cells(1,m.kol_cols).Value=m.col_znah
						CASE UPPER(LEFT(m.col_data,3))=="WT:"
							oExcel.Columns(m.kol_cols).ColumnWidth = VAL(m.col_znah)
						CASE UPPER(LEFT(m.col_data,3))=="WR:"
							kol_cols=IIF(m.kol_cols>26,CHR(64+INT(m.kol_cols/26)),"")+CHR(64+IIF(m.kol_cols%26=0,26,m.kol_cols%26))
							oExcel.Range(m.kol_cols+"2:"+m.kol_cols+ALLTRIM(STR(m.kol_rows))).WrapText = .T.
						ENDCASE
					ENDIF
				ENDFOR
			ENDIF
*--------------------------------------------------------------------------------------------
*	Операции с результатом
*--------------------------------------------------------------------------------------------
			DO CASE
			CASE "[EXCEL]"$UPPER(m.rep_config)			&& Вернуть объект для допиливания пользователем
				_my_rep=CreateObject("EXCEL_REP")  
				ADDPROPERTY(_my_rep, '_KolRow', m.kol_rows)
				ADDPROPERTY(_my_rep, '_KolCol', m.kol_cols)
				ADDPROPERTY(_my_rep, '_ColMax', m.col_maxlit)
				ADDPROPERTY(_my_rep, '_oExcel', m.oExcel)
				rep_error=m._my_rep
			CASE EMPTY(m.rep_xname)						&& не задан файл отчета
				oExcel.Visible= .T.						&& просто показываем результат
			OTHERWISE
				TRY
					oExcel.ActiveWorkbook.SaveAs(m.rep_xname,51)
				CATCH TO goto_error
					IF VARTYPE(m.proglang)="N" AND m.proglang=1	&& ENG
						rep_error="Error saving report: "+goto_error.message
					ELSE
						rep_error="Ошибка сохранения отчета: "+goto_error.message
					ENDIF
				ENDTRY
				oExcel.Quit
				IF EMPTY(m.rep_error) AND "[SHOW]"$UPPER(m.rep_config)	&& Показать отчет перезагрузкой, чтобы обнулить историю изменения файла
					WSHShell=CreateObject("WScript.Shell",0,.F.)
					WSHShell.Run('"'+m.rep_xname+'"')
				ENDIF
			ENDCASE
		ENDIF 
	ENDIF
	IF m.tmp_alias#m.rep_alias AND USED(m.tmp_alias)
		USE IN (m.tmp_alias)
	ENDIF
	IF !EMPTY(m.tek_alias) AND USED(m.tek_alias)
		SELECT (m.tek_alias)
	ENDIF
RETURN m.rep_error
DEFINE CLASS EXCEL_REP as Shape
ENDDEFINE

FUNCTION GEN_DIAGR		&& генерация графика с помощью EXCEL
PARAMETERS rep_alias,rep_xname,rep_config,rep_sourse,rep_filter,rep_nastr
*--------------------------------------------------------------------------------------------
* @ TAS - 2019 г.
*--------------------------------------------------------------------------------------------
* 1. rep_alias		- Alias источника данных, если не задан, то берется текущий.
* 2. rep_xname		- форма результа:
*		"C:TEMP\1.png"	- наименование файла, для сохранения графика.
*		"RAW"			- контент полученного файла.
*		"TMP"			- сгенерировать файл во временной папке (используется по умолчанию).
* 3. rep_config		- конфиг:
*		[Width=750]		- Ширина
*		[Height=500]	- Высота
*		[Type=-4101]	- Тип графика (см. XlChartType https://docs.microsoft.com/en-us/office/vba/api/excel.xlcharttype)
*		[Style=230]		- Стиль графика
*		[Format=PNG]	- Формат картинки (PNG - по умолчанию): png, gif, jpg, jpeg, bmp.
* 		можно добавить доп. параметры сюда...	
* 4. rep_sourse		- список полей для графика в виде "fields1,fields2,fields3" где первое поле должно содержать текст, 
*					а остальные числовые данные
* 5. rep_filter (не обязательно)- фильтр в виде условия для SQL запроса "field1=1 AND field2='ДА'" . Eсли не задан, то = "1=1".
* 6. rep_nastr (не обязательно)	- доп. настройки линий графика через разделители "|" между линиями.
*		"RGB:1=RGB(255, 0, 0)"	- ForeColor
*		"DS:1="	- DashStyle = 1 ... 8 (см. MsoLineDashStyle https://docs.microsoft.com/en-us/office/vba/api/office.msolinedashstyle)
*		"TP:1="	- Transparency = 0 ... 100
*		"SM:1="	- Smooth = .T./.F.
*		можно добавить доп. параметры сюда...
*--------------------------------------------------------------------------------------------
*	=GEN_DIAGR("reg","","","srf_name,srf_sum","RECNO()<=10","RGB:1=RGB(255,0,0)")
*--------------------------------------------------------------------------------------------
*	Проверки и первичная обработка входящих параметров
*--------------------------------------------------------------------------------------------
	LOCAL i,j, oExcel,zap_now, oChart, rep_error, rez_format
	LOCAL line_data, line_lit, line_nomr, line_data
	rep_error=''				&& Для ошибки
	rep_xname=IIF(VARTYPE(m.rep_xname)#"C","",m.rep_xname)
	rep_nastr=IIF(VARTYPE(m.rep_nastr)#"C","",m.rep_nastr)
	rep_xtemp=IIF(VARTYPE(m.rep_xname)#"C" OR EMPTY(m.rep_xname) OR UPPER(m.rep_xname)=="TMP" OR UPPER(m.rep_xname)=="RAW",SYS(2023)+'\'+SYS(3)+'.png',m.rep_xname)
	oExcel=DBF_TOEXCEL(m.rep_alias,"","[EXCEL]",m.rep_sourse,m.rep_filter)	
	rez_format="png"			&& формат результата по умолчанию
	IF VARTYPE(m.oExcel)#"O"	&& ошибка в DBF_TOEXCEL() при загрузке данных
		rep_error=m.oExcel
	ENDIF
*--------------------------------------------------------------------------------------------
* Настройка графика
*--------------------------------------------------------------------------------------------
	IF EMPTY(m.rep_error)
		TRY
			oChart=oExcel._oExcel.Worksheets.Item(1).Shapes.AddChart(4).Chart
			oChart.Axes(1).TickLabels.Orientation = 90
		    oChart.ChartStyle = 230
			oChart.PlotArea.Format.Fill.Visible= 0  			&& msoFalse
			FOR i=1 TO GETWORDCOUNT(m.rep_config,"]")			&& применяем доп настройки
				line_data=ALLTRIM(GETWORDNUM(m.rep_config,m.i,"]"))
				DO CASE
				CASE UPPER(LEFT(m.line_data,6))=="[WIDTH"
					oChart.ChartArea.Width = EVALUATE(SUBSTR(m.line_data,AT("=",m.line_data)+1))
				CASE UPPER(LEFT(m.line_data,7))=="[HEIGHT"
					oChart.ChartArea.Height = EVALUATE(SUBSTR(m.line_data,AT("=",m.line_data)+1))
				CASE UPPER(LEFT(m.line_data,5))=="[TYPE"
					oChart.ChartType = EVALUATE(SUBSTR(m.line_data,AT("=",m.line_data)+1))
				CASE UPPER(LEFT(m.line_data,6))=="[STYLE"
					oChart.ClearToMatchStyle
					oChart.ChartStyle = EVALUATE(SUBSTR(m.line_data,AT("=",m.line_data)+1))
				CASE UPPER(LEFT(m.line_data,7))=="[FORMAT"
					rez_format=ALLTRIM(SUBSTR(m.line_data,AT("=",m.line_data)+1))
					rep_xtemp=STRTRAN(LOWER(m.rep_xtemp),".png",LOWER("."+m.rez_format))
				ENDCASE
			ENDFOR
		CATCH TO goto_error
			rep_error="Ошибка настройки графика: "+goto_error.message
		ENDTRY
	ENDIF
*	oExcel._oExcel.Visible= .T.
*	SET STEP ON 
*--------------------------------------------------------------------------------------------
* Настройка линий графика
*--------------------------------------------------------------------------------------------
	IF EMPTY(m.rep_error)
		FOR i=1 TO GETWORDCOUNT(m.rep_sourse,",")-1
			WITH oChart.FullSeriesCollection(m.i)
				.Format.Line.Visible = .T.
			ENDWITH
		ENDFOR
		FOR i=1 TO GETWORDCOUNT(m.rep_nastr,"|")				&& применяем доп настройки
			line_data=ALLTRIM(GETWORDNUM(m.rep_nastr,m.i,"|"))
			line_lit=ALLTRIM(UPPER(GETWORDNUM(m.line_data,1,":")))
			line_nomr=INT(VAL(GETWORDNUM(GETWORDNUM(m.line_data,1,"="),2,":")))
			line_data=ALLTRIM(SUBSTR(m.line_data,AT("=",m.line_data)+1))
			IF !EMPTY(m.line_nomr)
				TRY
					WITH oChart.FullSeriesCollection(m.line_nomr)
						DO CASE
						CASE m.line_lit=="RGB"
							.Format.Line.ForeColor.RGB = EVALUATE(m.line_data)
						CASE m.line_lit=="DS"
							.Format.Line.DashStyle = EVALUATE(m.line_data)
						CASE m.line_lit=="TP"
							.Format.Line.Transparency = EVALUATE(m.line_data)
						CASE m.line_lit=="SM"
							.Smooth = EVALUATE(m.line_data)
						ENDCASE
					ENDWITH
				CATCH TO goto_error
					rep_error="Ошибка настройки линий графика: "+goto_error.message
				ENDTRY
			ENDIF
		ENDFOR
	ENDIF
*		oExcel._oExcel.Visible= .T.
*		SET STEP ON
*--------------------------------------------------------------------------------------------
* Завершающие операции
*--------------------------------------------------------------------------------------------
	IF EMPTY(m.rep_error)
		TRY
			=oChart.Export(m.rep_xtemp,m.rez_format)
			IF LEN(FILETOSTR(m.rep_xtemp))=0
				DELETE FILE (m.rep_xtemp)
				rep_error='Ошибка сохранения: не поддерживается формат "'+m.rez_format+'".'
			ENDIF
		CATCH TO goto_error
			rep_error="Ошибка сохранения графика: "+goto_error.message
		ENDTRY
		oExcel._oExcel.Application.DisplayAlerts=.F.
		oExcel._oExcel.Application.Quit
		oExcel=''
	ENDIF
	IF EMPTY(m.rep_error)	&& если успешно сформирован график
		IF m.rep_xname=="RAW"
			rep_error=FILETOSTR(m.rep_xtemp)	&& RAW
			DELETE FILE (m.rep_xtemp)
		ELSE
			rep_error=m.rep_xtemp				&& FullName
		ENDIF
		RETURN m.rep_error	&& путь файла | RAW PNG контент		
	ENDIF
RETURN "ERROR: "+m.rep_error	&& ошибка